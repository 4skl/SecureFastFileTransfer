<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- WiFi and Network permissions for file transfer --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- File access permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;&#10;    &lt;!-- Camera permission for QR code scanning --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;!-- Android 13+ permissions for nearby devices --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.NEARBY_WIFI_DEVICES&quot; /&gt;&#10;&#10;    &lt;!-- Required for Camera (QR code scanning) --&gt;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- FileTransferService for encrypted file transfers --&gt;&#10;        &lt;service android:name=&quot;.FileTransferService&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- WiFi and Network permissions for file transfer --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- File access permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#10;                     android:maxSdkVersion=&quot;32&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#10;                     android:maxSdkVersion=&quot;29&quot; /&gt;&#10;    &#10;    &lt;!-- Android 13+ permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; &#10;                     tools:ignore=&quot;ScopedStorage&quot; /&gt;&#10;&#10;    &lt;!-- Camera permission for QR code scanning --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;!-- Android 13+ permissions for nearby devices --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.NEARBY_WIFI_DEVICES&quot; /&gt;&#10;&#10;    &lt;!-- Required for Camera (QR code scanning) --&gt;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:requestLegacyExternalStorage=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- FileTransferService for encrypted file transfers --&gt;&#10;        &lt;service android:name=&quot;.FileTransferService&quot; /&gt;&#10;&#10;        &lt;!-- File provider for secure file access --&gt;&#10;        &lt;provider&#10;            android:name=&quot;androidx.core.content.FileProvider&quot;&#10;            android:authorities=&quot;${applicationId}.fileprovider&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:grantUriPermissions=&quot;true&quot;&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;&#10;                android:resource=&quot;@xml/file_paths&quot; /&gt;&#10;        &lt;/provider&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/FileTransferService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/FileTransferService.kt" />
              <option name="originalContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.app.IntentService&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.io.*&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class FileTransferService : IntentService(&quot;FileTransferService&quot;) {&#10;&#10;    companion object {&#10;        const val ACTION_SEND_FILE = &quot;com.skl.nfconnect.SEND_FILE&quot;&#10;        const val ACTION_RECEIVE_FILE = &quot;com.skl.nfconnect.RECEIVE_FILE&quot;&#10;        const val EXTRA_FILE_PATH = &quot;file_path&quot;&#10;        const val EXTRA_HOST = &quot;host_address&quot;&#10;        const val EXTRA_SECRET = &quot;shared_secret&quot;&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;&#10;        fun startService(context: Context, action: String, filePath: String? = null, hostAddress: String? = null, secret: String) {&#10;            val intent = Intent(context, FileTransferService::class.java).apply {&#10;                this.action = action&#10;                putExtra(EXTRA_SECRET, secret)&#10;                filePath?.let { putExtra(EXTRA_FILE_PATH, it) }&#10;                hostAddress?.let { putExtra(EXTRA_HOST, it) }&#10;            }&#10;            context.startService(intent)&#10;        }&#10;    }&#10;&#10;    override fun onHandleIntent(intent: Intent?) {&#10;        intent ?: return&#10;&#10;        when (intent.action) {&#10;            ACTION_SEND_FILE -&gt; {&#10;                val filePath = intent.getStringExtra(EXTRA_FILE_PATH)&#10;                val hostAddress = intent.getStringExtra(EXTRA_HOST)&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                if (filePath != null &amp;&amp; hostAddress != null &amp;&amp; secret != null) {&#10;                    sendFile(filePath, hostAddress, secret)&#10;                }&#10;            }&#10;            ACTION_RECEIVE_FILE -&gt; {&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                if (secret != null) {&#10;                    receiveFile(secret)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendFile(filePath: String, hostAddress: String, secret: String) {&#10;        try {&#10;            val file = File(filePath)&#10;            val fileBytes = file.readBytes()&#10;&#10;            // Encrypt the file using the shared secret&#10;            val encryptedData = CryptoHelper.encryptFile(fileBytes, secret)&#10;            if (encryptedData == null) {&#10;                throw Exception(&quot;Failed to encrypt file&quot;)&#10;            }&#10;&#10;            val socket = Socket(hostAddress, FILE_TRANSFER_PORT)&#10;            val outputStream = socket.getOutputStream()&#10;            val dataOutputStream = DataOutputStream(outputStream)&#10;&#10;            // Send file name first&#10;            dataOutputStream.writeUTF(file.name)&#10;            // Send encrypted data size&#10;            dataOutputStream.writeLong(encryptedData.data.size.toLong())&#10;            // Send IV size and IV&#10;            dataOutputStream.writeInt(encryptedData.iv.size)&#10;            dataOutputStream.write(encryptedData.iv)&#10;&#10;            // Send encrypted file data&#10;            dataOutputStream.write(encryptedData.data)&#10;&#10;            dataOutputStream.close()&#10;            socket.close()&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Encrypted file sent successfully: ${file.name}&quot;)&#10;&#10;            // Broadcast success&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File sent successfully&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error sending file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to send file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;&#10;    private fun receiveFile(secret: String) {&#10;        try {&#10;            val serverSocket = ServerSocket(FILE_TRANSFER_PORT)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Waiting for encrypted file transfer...&quot;)&#10;&#10;            val socket = serverSocket.accept()&#10;            val inputStream = socket.getInputStream()&#10;            val dataInputStream = DataInputStream(inputStream)&#10;&#10;            // Receive file name&#10;            val fileName = dataInputStream.readUTF()&#10;            // Receive encrypted data size&#10;            val encryptedSize = dataInputStream.readLong()&#10;            // Receive IV&#10;            val ivSize = dataInputStream.readInt()&#10;            val iv = ByteArray(ivSize)&#10;            dataInputStream.readFully(iv)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Receiving encrypted file: $fileName, size: $encryptedSize bytes&quot;)&#10;&#10;            // Receive encrypted data&#10;            val encryptedData = ByteArray(encryptedSize.toInt())&#10;            dataInputStream.readFully(encryptedData)&#10;&#10;            dataInputStream.close()&#10;            serverSocket.close()&#10;&#10;            // Decrypt the file&#10;            val encryptedFileData = CryptoHelper.EncryptedData(encryptedData, iv)&#10;            val decryptedBytes = CryptoHelper.decryptFile(encryptedFileData, secret)&#10;&#10;            if (decryptedBytes == null) {&#10;                throw Exception(&quot;Failed to decrypt file - incorrect secret or corrupted data&quot;)&#10;            }&#10;&#10;            // Save decrypted file to Downloads directory&#10;            val downloadsDir = File(getExternalFilesDir(null), &quot;Downloads&quot;)&#10;            if (!downloadsDir.exists()) {&#10;                downloadsDir.mkdirs()&#10;            }&#10;            val receivedFile = File(downloadsDir, fileName)&#10;            receivedFile.writeBytes(decryptedBytes)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File decrypted and saved successfully: $fileName&quot;)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to: ${receivedFile.absolutePath}&quot;)&#10;&#10;            // Broadcast success with file path&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File received and decrypted successfully: $fileName&quot;)&#10;            broadcastIntent.putExtra(&quot;file_path&quot;, receivedFile.absolutePath)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error receiving file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to receive file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.app.IntentService&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.documentfile.provider.DocumentFile&#10;import java.io.*&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class FileTransferService : IntentService(&quot;FileTransferService&quot;) {&#10;&#10;    companion object {&#10;        const val ACTION_SEND_FILE = &quot;com.skl.securefastfiletransfer.SEND_FILE&quot;&#10;        const val ACTION_RECEIVE_FILE = &quot;com.skl.securefastfiletransfer.RECEIVE_FILE&quot;&#10;        const val EXTRA_FILE_PATH = &quot;file_path&quot;&#10;        const val EXTRA_HOST = &quot;host_address&quot;&#10;        const val EXTRA_SECRET = &quot;shared_secret&quot;&#10;        const val EXTRA_SAVE_DIRECTORY_URI = &quot;save_directory_uri&quot;&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;&#10;        fun startService(&#10;            context: Context,&#10;            action: String,&#10;            filePath: String? = null,&#10;            hostAddress: String? = null,&#10;            secret: String,&#10;            saveDirectoryUri: Uri? = null&#10;        ) {&#10;            val intent = Intent(context, FileTransferService::class.java).apply {&#10;                this.action = action&#10;                putExtra(EXTRA_SECRET, secret)&#10;                filePath?.let { putExtra(EXTRA_FILE_PATH, it) }&#10;                hostAddress?.let { putExtra(EXTRA_HOST, it) }&#10;                saveDirectoryUri?.let { putExtra(EXTRA_SAVE_DIRECTORY_URI, it.toString()) }&#10;            }&#10;            context.startService(intent)&#10;        }&#10;    }&#10;&#10;    override fun onHandleIntent(intent: Intent?) {&#10;        intent ?: return&#10;&#10;        when (intent.action) {&#10;            ACTION_SEND_FILE -&gt; {&#10;                val filePath = intent.getStringExtra(EXTRA_FILE_PATH)&#10;                val hostAddress = intent.getStringExtra(EXTRA_HOST)&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                if (filePath != null &amp;&amp; hostAddress != null &amp;&amp; secret != null) {&#10;                    sendFile(filePath, hostAddress, secret)&#10;                }&#10;            }&#10;            ACTION_RECEIVE_FILE -&gt; {&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                val saveDirectoryUriString = intent.getStringExtra(EXTRA_SAVE_DIRECTORY_URI)&#10;                val saveDirectoryUri = saveDirectoryUriString?.let { Uri.parse(it) }&#10;                if (secret != null) {&#10;                    receiveFile(secret, saveDirectoryUri)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendFile(filePath: String, hostAddress: String, secret: String) {&#10;        try {&#10;            val file = File(filePath)&#10;            val fileBytes = file.readBytes()&#10;&#10;            // Encrypt the file using the shared secret&#10;            val encryptedData = CryptoHelper.encryptFile(fileBytes, secret)&#10;            if (encryptedData == null) {&#10;                throw Exception(&quot;Failed to encrypt file&quot;)&#10;            }&#10;&#10;            val socket = Socket(hostAddress, FILE_TRANSFER_PORT)&#10;            val outputStream = socket.getOutputStream()&#10;            val dataOutputStream = DataOutputStream(outputStream)&#10;&#10;            // Send file name first&#10;            dataOutputStream.writeUTF(file.name)&#10;            // Send encrypted data size&#10;            dataOutputStream.writeLong(encryptedData.data.size.toLong())&#10;            // Send IV size and IV&#10;            dataOutputStream.writeInt(encryptedData.iv.size)&#10;            dataOutputStream.write(encryptedData.iv)&#10;&#10;            // Send encrypted file data&#10;            dataOutputStream.write(encryptedData.data)&#10;&#10;            dataOutputStream.close()&#10;            socket.close()&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Encrypted file sent successfully: ${file.name}&quot;)&#10;&#10;            // Broadcast success with consistent action&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File sent successfully&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error sending file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to send file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;&#10;    private fun receiveFile(secret: String, saveDirectoryUri: Uri?) {&#10;        try {&#10;            val serverSocket = ServerSocket(FILE_TRANSFER_PORT)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Waiting for encrypted file transfer...&quot;)&#10;&#10;            val socket = serverSocket.accept()&#10;            val inputStream = socket.getInputStream()&#10;            val dataInputStream = DataInputStream(inputStream)&#10;&#10;            // Receive file name&#10;            val fileName = dataInputStream.readUTF()&#10;            // Receive encrypted data size&#10;            val encryptedSize = dataInputStream.readLong()&#10;            // Receive IV&#10;            val ivSize = dataInputStream.readInt()&#10;            val iv = ByteArray(ivSize)&#10;            dataInputStream.readFully(iv)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Receiving encrypted file: $fileName, size: $encryptedSize bytes&quot;)&#10;&#10;            // Receive encrypted data&#10;            val encryptedData = ByteArray(encryptedSize.toInt())&#10;            dataInputStream.readFully(encryptedData)&#10;&#10;            dataInputStream.close()&#10;            serverSocket.close()&#10;&#10;            // Decrypt the file&#10;            val encryptedFileData = CryptoHelper.EncryptedData(encryptedData, iv)&#10;            val decryptedBytes = CryptoHelper.decryptFile(encryptedFileData, secret)&#10;&#10;            if (decryptedBytes == null) {&#10;                throw Exception(&quot;Failed to decrypt file - incorrect secret or corrupted data&quot;)&#10;            }&#10;&#10;            // Save file to user-selected directory or fallback to app directory&#10;            val savedFilePath = saveFileToSelectedDirectory(fileName, decryptedBytes, saveDirectoryUri)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File decrypted and saved successfully: $fileName&quot;)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to: $savedFilePath&quot;)&#10;&#10;            // Broadcast success with file path and consistent action&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File received and decrypted successfully: $fileName&quot;)&#10;            broadcastIntent.putExtra(&quot;file_path&quot;, savedFilePath)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error receiving file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to receive file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;&#10;    private fun saveFileToSelectedDirectory(fileName: String, fileBytes: ByteArray, saveDirectoryUri: Uri?): String {&#10;        Log.d(&quot;FileTransferService&quot;, &quot;Attempting to save file: $fileName&quot;)&#10;        Log.d(&quot;FileTransferService&quot;, &quot;Save directory URI: $saveDirectoryUri&quot;)&#10;&#10;        return try {&#10;            if (saveDirectoryUri != null) {&#10;                Log.d(&quot;FileTransferService&quot;, &quot;Using user-selected directory&quot;)&#10;                // Save to user-selected directory using DocumentFile&#10;                val directory = DocumentFile.fromTreeUri(this, saveDirectoryUri)&#10;                if (directory != null &amp;&amp; directory.exists()) {&#10;                    Log.d(&quot;FileTransferService&quot;, &quot;Directory is valid and exists&quot;)&#10;                    val newFile = directory.createFile(&quot;*/*&quot;, fileName)&#10;                    if (newFile != null) {&#10;                        Log.d(&quot;FileTransferService&quot;, &quot;Created new file in selected directory&quot;)&#10;                        contentResolver.openOutputStream(newFile.uri)?.use { outputStream -&gt;&#10;                            outputStream.write(fileBytes)&#10;                        }&#10;                        Log.d(&quot;FileTransferService&quot;, &quot;File saved successfully to: ${newFile.uri}&quot;)&#10;                        return newFile.uri.toString()&#10;                    } else {&#10;                        Log.w(&quot;FileTransferService&quot;, &quot;Failed to create file in selected directory&quot;)&#10;                    }&#10;                } else {&#10;                    Log.w(&quot;FileTransferService&quot;, &quot;Selected directory is null or doesn't exist&quot;)&#10;                }&#10;            } else {&#10;                Log.d(&quot;FileTransferService&quot;, &quot;No save directory provided, using fallback&quot;)&#10;            }&#10;&#10;            // Fallback: Save to app's external files directory&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Using fallback directory&quot;)&#10;            val downloadsDir = File(getExternalFilesDir(null), &quot;Downloads&quot;)&#10;            if (!downloadsDir.exists()) {&#10;                downloadsDir.mkdirs()&#10;            }&#10;            val receivedFile = File(downloadsDir, fileName)&#10;            receivedFile.writeBytes(fileBytes)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to fallback location: ${receivedFile.absolutePath}&quot;)&#10;            receivedFile.absolutePath&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error saving file: ${e.message}&quot;)&#10;            // Emergency fallback: Save to cache directory&#10;            val cacheFile = File(cacheDir, fileName)&#10;            cacheFile.writeBytes(fileBytes)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to emergency cache: ${cacheFile.absolutePath}&quot;)&#10;            cacheFile.absolutePath&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/MainActivity.kt" />
              <option name="originalContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.content.Context&#10;import android.provider.OpenableColumns&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import java.util.UUID&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.text.style.TextAlign&#10;import java.io.File&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.graphics.Bitmap&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import com.journeyapps.barcodescanner.ScanContract&#10;import com.journeyapps.barcodescanner.ScanOptions&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import android.content.pm.PackageManager&#10;import android.os.Environment&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.documentfile.provider.DocumentFile&#10;&#10;class MainActivity : ComponentActivity(), WiFiTransferHelper.TransferListener {&#10;    private lateinit var wifiTransferHelper: WiFiTransferHelper&#10;    private var handshakeSecret: String? = null&#10;    private var isSender = false&#10;    private var showConfirmDialog by mutableStateOf(false)&#10;    private var status by mutableStateOf(&quot;Ready to start secure file transfer&quot;)&#10;    private var selectedFileUri: Uri? = null&#10;    private var selectedSaveDirectory: Uri? = null&#10;    private var peerIpAddress: String? = null&#10;    private var waitingForSecret by mutableStateOf(false)&#10;    private var displayedSecret by mutableStateOf(&quot;&quot;)&#10;    private var showQRCode by mutableStateOf(false)&#10;    private var qrCodeBitmap by mutableStateOf&lt;Bitmap?&gt;(null)&#10;    private var showManualSecretDialog by mutableStateOf(false)&#10;    private var manualSecretInput by mutableStateOf(&quot;&quot;)&#10;    private var showFileReceivedDialog by mutableStateOf(false)&#10;    private var receivedFilePath by mutableStateOf(&quot;&quot;)&#10;    private var showPermissionDialog by mutableStateOf(false)&#10;&#10;    // Permission request launcher&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (!allGranted) {&#10;            Toast.makeText(this, &quot;Permissions are required for file transfer&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    // Directory picker launcher for receiver&#10;    private val directoryPickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.OpenDocumentTree()&#10;    ) { uri: Uri? -&gt;&#10;        if (uri != null) {&#10;            selectedSaveDirectory = uri&#10;            // Grant persistent permission&#10;            contentResolver.takePersistableUriPermission(&#10;                uri,&#10;                Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION&#10;            )&#10;            status = &quot;Save directory selected. Ready to scan QR code or enter secret.&quot;&#10;            waitingForSecret = true&#10;        } else {&#10;            Toast.makeText(this, &quot;Please select a directory to save received files&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    // QR Code scanner launcher&#10;    private val qrScannerLauncher = registerForActivityResult(ScanContract()) { result -&gt;&#10;        if (result.contents != null) {&#10;            val scannedSecret = result.contents&#10;            if (QRCodeHelper.isValidSecret(scannedSecret)) {&#10;                handshakeSecret = scannedSecret&#10;                displayedSecret = scannedSecret.take(12) + &quot;...&quot;&#10;                status = &quot;Secret scanned! Connecting to sender...&quot;&#10;                waitingForSecret = false&#10;                startWifiTransfer()&#10;            } else {&#10;                Toast.makeText(this, &quot;Invalid QR code. Please scan a valid secret code.&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        } else {&#10;            Toast.makeText(this, &quot;QR code scan cancelled&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private val fileTransferReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            if (intent?.action == &quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;) {&#10;                val success = intent.getBooleanExtra(&quot;success&quot;, false)&#10;                val message = intent.getStringExtra(&quot;message&quot;) ?: &quot;Unknown result&quot;&#10;                val filePath = intent.getStringExtra(&quot;file_path&quot;)&#10;&#10;                runOnUiThread {&#10;                    status = message&#10;                    if (success) {&#10;                        if (!isSender &amp;&amp; filePath != null) {&#10;                            // Show file received dialog for receiver&#10;                            receivedFilePath = filePath&#10;                            showFileReceivedDialog = true&#10;                        }&#10;                        Toast.makeText(this@MainActivity, &quot;Transfer completed successfully!&quot;, Toast.LENGTH_LONG).show()&#10;                        resetToIdle()&#10;                    } else {&#10;                        Toast.makeText(this@MainActivity, &quot;Transfer failed: $message&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val pickFileLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? -&gt;&#10;        if (uri != null) {&#10;            selectedFileUri = uri&#10;            val fileName = getFileNameFromUri(this, uri)&#10;            // Generate secret immediately when file is selected&#10;            val generatedSecret = UUID.randomUUID().toString()&#10;            handshakeSecret = generatedSecret&#10;            displayedSecret = generatedSecret.take(12) + &quot;...&quot;&#10;            status = &quot;File selected: $fileName. Share the QR code or secret with receiver.&quot;&#10;&#10;            // Generate QR code&#10;            qrCodeBitmap = QRCodeHelper.generateQRCode(generatedSecret, 400)&#10;            showQRCode = true&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        wifiTransferHelper = WiFiTransferHelper(this)&#10;&#10;        // Register broadcast receiver for file transfer updates&#10;        val filter = IntentFilter(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            registerReceiver(fileTransferReceiver, filter, Context.RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            registerReceiver(fileTransferReceiver, filter)&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(innerPadding)&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Secure File Transfer&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;                    ) {&#10;                        Text(&#10;                            text = status,&#10;                            modifier = Modifier.padding(16.dp),&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            isSender = true&#10;                            resetState()&#10;                            status = &quot;Select a file to send&quot;&#10;                            pickFileLauncher.launch(&quot;*/*&quot;)&#10;                        },&#10;                        enabled = !waitingForSecret&#10;                    ) {&#10;                        Text(&quot;Send File&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            isSender = false&#10;                            resetState()&#10;                            status = &quot;Select a directory to save received files&quot;&#10;                            // Open directory picker for receiver&#10;                            directoryPickerLauncher.launch(null)&#10;                        },&#10;                        enabled = !waitingForSecret&#10;                    ) {&#10;                        Text(&quot;Receive File&quot;)&#10;                    }&#10;&#10;                    if (displayedSecret.isNotEmpty()) {&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier.padding(16.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Secret Code:&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                Text(&#10;                                    text = displayedSecret,&#10;                                    style = MaterialTheme.typography.headlineSmall,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = MaterialTheme.colorScheme.primary&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Show this QR code to the receiver or verify codes match!&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    textAlign = TextAlign.Center&#10;                                )&#10;&#10;                                if (isSender &amp;&amp; qrCodeBitmap != null) {&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Button(&#10;                                        onClick = {&#10;                                            showQRCode = true&#10;                                        }&#10;                                    ) {&#10;                                        Text(&quot;Show QR Code&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Scan QR Code button for receivers&#10;                    if (waitingForSecret) {&#10;                        Button(&#10;                            onClick = {&#10;                                val options = ScanOptions().apply {&#10;                                    setPrompt(&quot;Scan the sender's QR code&quot;)&#10;                                    setBeepEnabled(true)&#10;                                    setOrientationLocked(false) // Allow rotation for better scanning&#10;                                    setBarcodeImageEnabled(true)&#10;                                    setDesiredBarcodeFormats(ScanOptions.QR_CODE)&#10;                                    setCameraId(0) // Use back camera&#10;                                    setTimeout(30000) // 30 second timeout&#10;                                }&#10;                                qrScannerLauncher.launch(options)&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Scan QR Code&quot;)&#10;                        }&#10;                    }&#10;&#10;                    if (waitingForSecret) {&#10;                        Button(&#10;                            onClick = {&#10;                                // Manual secret input&#10;                                showManualSecretDialog = true&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Enter Secret Manually&quot;)&#10;                        }&#10;                    }&#10;&#10;                    if (showConfirmDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {},&#10;                            title = { Text(&quot;Connection Verified&quot;) },&#10;                            text = { Text(&quot;Both devices have the same secret. Do the secret codes match on both screens before proceeding? Allow file transfer to proceed?&quot;) },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showConfirmDialog = false&#10;                                    startFileTransfer()&#10;                                }) { Text(&quot;Yes, Start Transfer&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showConfirmDialog = false&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;No, Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (showQRCode) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showQRCode = false&#10;                            },&#10;                            title = { Text(&quot;Share QR Code&quot;) },&#10;                            text = {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Show this QR code to the receiver to share the secret.&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                    // QR code image&#10;                                    qrCodeBitmap?.let { bitmap -&gt;&#10;                                        Image(&#10;                                            bitmap = bitmap.asImageBitmap(),&#10;                                            contentDescription = &quot;QR Code&quot;,&#10;                                            modifier = Modifier.size(250.dp)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showQRCode = false&#10;                                    // Start WiFi transfer after showing QR code&#10;                                    startWifiTransfer()&#10;                                }) { Text(&quot;Continue&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showQRCode = false&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (showManualSecretDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showManualSecretDialog = false&#10;                            },&#10;                            title = { Text(&quot;Enter Secret Manually&quot;) },&#10;                            text = {&#10;                                Column {&#10;                                    Text(&#10;                                        text = &quot;Enter the complete secret code from the sender's device.&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    // Text field for manual secret input&#10;                                    TextField(&#10;                                        value = manualSecretInput,&#10;                                        onValueChange = { manualSecretInput = it },&#10;                                        label = { Text(&quot;Secret Code&quot;) },&#10;                                        singleLine = true,&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                }&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    // Verify and proceed with manual secret&#10;                                    if (manualSecretInput.length &gt;= 30) { // UUID length&#10;                                        handshakeSecret = manualSecretInput&#10;                                        displayedSecret = manualSecretInput.take(12)&#10;                                        status = &quot;Secret received! Connecting to sender...&quot;&#10;                                        showManualSecretDialog = false&#10;                                        waitingForSecret = false&#10;                                        manualSecretInput = &quot;&quot; // Clear the input&#10;                                        startWifiTransfer()&#10;                                    } else {&#10;                                        Toast.makeText(this@MainActivity, &quot;Please enter the complete secret code (should be around 36 characters)&quot;, Toast.LENGTH_LONG).show()&#10;                                    }&#10;                                }) { Text(&quot;Confirm Secret&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showManualSecretDialog = false&#10;                                    manualSecretInput = &quot;&quot; // Clear the input&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Show received file dialog&#10;                    if (showFileReceivedDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showFileReceivedDialog = false&#10;                            },&#10;                            title = { Text(&quot;File Received&quot;) },&#10;                            text = {&#10;                                Column {&#10;                                    Text(&#10;                                        text = &quot;The file has been received successfully.&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;File path: $receivedFilePath&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall,&#10;                                        textAlign = TextAlign.Start&#10;                                    )&#10;                                }&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showFileReceivedDialog = false&#10;                                }) { Text(&quot;OK&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Request permissions if not granted&#10;                    if (waitingForSecret &amp;&amp; !hasRequiredPermissions()) {&#10;                        LaunchedEffect(Unit) {&#10;                            // Show permission rationale and request permissions&#10;                            showPermissionDialog = true&#10;                        }&#10;                    }&#10;&#10;                    if (showPermissionDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showPermissionDialog = false&#10;                            },&#10;                            title = { Text(&quot;Permissions Required&quot;) },&#10;                            text = {&#10;                                Text(&#10;                                    text = &quot;This app requires certain permissions to be granted for file transfer to work. Please allow the required permissions.&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showPermissionDialog = false&#10;                                    // Request permissions&#10;                                    requestRequiredPermissions()&#10;                                }) { Text(&quot;Grant Permissions&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showPermissionDialog = false&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetState() {&#10;        handshakeSecret = null&#10;        displayedSecret = &quot;&quot;&#10;        selectedFileUri = null&#10;        peerIpAddress = null&#10;    }&#10;&#10;    private fun resetToIdle() {&#10;        waitingForSecret = false&#10;        showConfirmDialog = false&#10;        status = &quot;Ready to start secure file transfer&quot;&#10;        isSender = false&#10;        resetState()&#10;    }&#10;&#10;    private fun getFileNameFromUri(context: Context, uri: Uri): String? {&#10;        val cursor = context.contentResolver.query(uri, null, null, null, null)&#10;        return cursor?.use {&#10;            if (it.moveToFirst()) {&#10;                val index = it.getColumnIndex(OpenableColumns.DISPLAY_NAME)&#10;                if (index &gt;= 0) it.getString(index) else null&#10;            } else null&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        unregisterReceiver(fileTransferReceiver)&#10;        wifiTransferHelper.cleanup()&#10;    }&#10;&#10;    // WiFiTransferHelper.TransferListener implementation&#10;    override fun onTransferProgress(bytesTransferred: Long, totalBytes: Long) {&#10;        runOnUiThread {&#10;            val progress = (bytesTransferred * 100 / totalBytes).toInt()&#10;            status = &quot;Transfer progress: $progress%&quot;&#10;        }&#10;    }&#10;&#10;    override fun onTransferComplete(success: Boolean, message: String) {&#10;        runOnUiThread {&#10;            status = message&#10;            if (success) {&#10;                Toast.makeText(this, &quot;Transfer completed successfully!&quot;, Toast.LENGTH_LONG).show()&#10;                resetToIdle()&#10;            } else {&#10;                Toast.makeText(this, &quot;Transfer failed: $message&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPeerDiscovered(peerIp: String) {&#10;        runOnUiThread {&#10;            status = &quot;Found peer device on network: $peerIp&quot;&#10;        }&#10;    }&#10;&#10;    override fun onConnectionEstablished(peerIp: String) {&#10;        runOnUiThread {&#10;            peerIpAddress = peerIp&#10;            status = &quot;Connected to peer device. Verifying secrets...&quot;&#10;            showConfirmDialog = true&#10;        }&#10;    }&#10;&#10;    private fun startWifiTransfer() {&#10;        if (handshakeSecret != null) {&#10;            wifiTransferHelper.setTransferListener(this)&#10;            if (isSender) {&#10;                status = &quot;Starting as sender. Looking for receiver...&quot;&#10;                wifiTransferHelper.startSender(handshakeSecret!!)&#10;            } else {&#10;                status = &quot;Starting as receiver. Looking for sender...&quot;&#10;                wifiTransferHelper.startReceiver(handshakeSecret!!)&#10;                // Start file receiver immediately for receiver&#10;                wifiTransferHelper.startFileReceiver()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startFileTransfer() {&#10;        if (isSender) {&#10;            if (selectedFileUri == null || peerIpAddress == null) {&#10;                status = &quot;Missing file or peer connection&quot;&#10;                return&#10;            }&#10;&#10;            val filePath = copyUriToCache(selectedFileUri!!)&#10;            if (filePath == null) {&#10;                status = &quot;Failed to prepare file for transfer&quot;&#10;                return&#10;            }&#10;&#10;            status = &quot;Sending encrypted file...&quot;&#10;            wifiTransferHelper.sendFile(filePath, peerIpAddress!!)&#10;        } else {&#10;            status = &quot;Ready to receive encrypted file...&quot;&#10;            // Pass the selected directory to the file receiver&#10;            wifiTransferHelper.startFileReceiver(selectedSaveDirectory)&#10;        }&#10;    }&#10;&#10;    private fun copyUriToCache(uri: Uri): String? {&#10;        return try {&#10;            val fileName = getFileNameFromUri(this, uri) ?: &quot;tempfile&quot;&#10;            val file = File(cacheDir, fileName)&#10;            contentResolver.openInputStream(uri)?.use { input -&gt;&#10;                java.io.FileOutputStream(file).use { output -&gt;&#10;                    input.copyTo(output)&#10;                }&#10;            }&#10;            file.absolutePath&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    fun onSecretVerified(groupOwnerAddress: String?) {&#10;        runOnUiThread {&#10;            if (isSender &amp;&amp; groupOwnerAddress != null) {&#10;                this@MainActivity.peerIpAddress = groupOwnerAddress&#10;            }&#10;            status = &quot;Connection established! Secrets match.&quot;&#10;            showConfirmDialog = true&#10;        }&#10;    }&#10;&#10;    fun onSecretRejected() {&#10;        runOnUiThread {&#10;            status = &quot;Secret verification failed! Connection rejected for security.&quot;&#10;            Toast.makeText(this@MainActivity, &quot;Security check failed - secrets don't match!&quot;, Toast.LENGTH_LONG).show()&#10;            resetToIdle()&#10;        }&#10;    }&#10;&#10;    private fun requestRequiredPermissions() {&#10;        val permissions = mutableListOf&lt;String&gt;()&#10;&#10;        // Add permissions based on Android version&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            permissions.addAll(listOf(&#10;                Manifest.permission.READ_MEDIA_IMAGES,&#10;                Manifest.permission.READ_MEDIA_VIDEO,&#10;                Manifest.permission.READ_MEDIA_AUDIO,&#10;                Manifest.permission.CAMERA&#10;            ))&#10;        } else {&#10;            permissions.addAll(listOf(&#10;                Manifest.permission.READ_EXTERNAL_STORAGE,&#10;                Manifest.permission.WRITE_EXTERNAL_STORAGE,&#10;                Manifest.permission.CAMERA&#10;            ))&#10;        }&#10;&#10;        permissions.addAll(listOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        ))&#10;&#10;        permissionLauncher.launch(permissions.toTypedArray())&#10;    }&#10;&#10;    private fun hasRequiredPermissions(): Boolean {&#10;        val cameraPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED&#10;        val locationPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        val wifiPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_WIFI_STATE) == PackageManager.PERMISSION_GRANTED&#10;&#10;        val storagePermission = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES) == PackageManager.PERMISSION_GRANTED&#10;        } else {&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        return cameraPermission &amp;&amp; locationPermission &amp;&amp; wifiPermission &amp;&amp; storagePermission&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.content.Context&#10;import android.provider.OpenableColumns&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.material3.TextField&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import java.util.UUID&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.text.style.TextAlign&#10;import java.io.File&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.graphics.Bitmap&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import com.journeyapps.barcodescanner.ScanContract&#10;import com.journeyapps.barcodescanner.ScanOptions&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import android.content.pm.PackageManager&#10;import android.os.Environment&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.documentfile.provider.DocumentFile&#10;&#10;class MainActivity : ComponentActivity(), WiFiTransferHelper.TransferListener {&#10;    private lateinit var wifiTransferHelper: WiFiTransferHelper&#10;    private var handshakeSecret: String? = null&#10;    private var isSender = false&#10;    private var showConfirmDialog by mutableStateOf(false)&#10;    private var status by mutableStateOf(&quot;Ready to start secure file transfer&quot;)&#10;    private var selectedFileUri: Uri? = null&#10;    private var selectedSaveDirectory: Uri? = null&#10;    private var peerIpAddress: String? = null&#10;    private var waitingForSecret by mutableStateOf(false)&#10;    private var displayedSecret by mutableStateOf(&quot;&quot;)&#10;    private var showQRCode by mutableStateOf(false)&#10;    private var qrCodeBitmap by mutableStateOf&lt;Bitmap?&gt;(null)&#10;    private var showManualSecretDialog by mutableStateOf(false)&#10;    private var manualSecretInput by mutableStateOf(&quot;&quot;)&#10;    private var showFileReceivedDialog by mutableStateOf(false)&#10;    private var receivedFilePath by mutableStateOf(&quot;&quot;)&#10;    private var showPermissionDialog by mutableStateOf(false)&#10;&#10;    // Permission request launcher&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (!allGranted) {&#10;            Toast.makeText(this, &quot;Permissions are required for file transfer&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    // Directory picker launcher for receiver&#10;    private val directoryPickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.OpenDocumentTree()&#10;    ) { uri: Uri? -&gt;&#10;        if (uri != null) {&#10;            selectedSaveDirectory = uri&#10;            // Grant persistent permission&#10;            contentResolver.takePersistableUriPermission(&#10;                uri,&#10;                Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION&#10;            )&#10;            status = &quot;Save directory selected. Ready to scan QR code or enter secret.&quot;&#10;            waitingForSecret = true&#10;        } else {&#10;            Toast.makeText(this, &quot;Please select a directory to save received files&quot;, Toast.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;    // QR Code scanner launcher&#10;    private val qrScannerLauncher = registerForActivityResult(ScanContract()) { result -&gt;&#10;        if (result.contents != null) {&#10;            val scannedSecret = result.contents&#10;            if (QRCodeHelper.isValidSecret(scannedSecret)) {&#10;                handshakeSecret = scannedSecret&#10;                displayedSecret = scannedSecret.take(12) + &quot;...&quot;&#10;                status = &quot;Secret scanned! Connecting to sender...&quot;&#10;                waitingForSecret = false&#10;                startWifiTransfer()&#10;            } else {&#10;                Toast.makeText(this, &quot;Invalid QR code. Please scan a valid secret code.&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        } else {&#10;            Toast.makeText(this, &quot;QR code scan cancelled&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    private val fileTransferReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            if (intent?.action == &quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;) {&#10;                val success = intent.getBooleanExtra(&quot;success&quot;, false)&#10;                val message = intent.getStringExtra(&quot;message&quot;) ?: &quot;Unknown result&quot;&#10;                val filePath = intent.getStringExtra(&quot;file_path&quot;)&#10;&#10;                runOnUiThread {&#10;                    status = message&#10;                    if (success) {&#10;                        if (!isSender &amp;&amp; filePath != null) {&#10;                            // Show file received dialog for receiver&#10;                            receivedFilePath = filePath&#10;                            showFileReceivedDialog = true&#10;                        }&#10;                        Toast.makeText(this@MainActivity, &quot;Transfer completed successfully!&quot;, Toast.LENGTH_LONG).show()&#10;                        resetToIdle()&#10;                    } else {&#10;                        Toast.makeText(this@MainActivity, &quot;Transfer failed: $message&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val pickFileLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? -&gt;&#10;        if (uri != null) {&#10;            selectedFileUri = uri&#10;            val fileName = getFileNameFromUri(this, uri)&#10;            // Generate secret immediately when file is selected&#10;            val generatedSecret = UUID.randomUUID().toString()&#10;            handshakeSecret = generatedSecret&#10;            displayedSecret = generatedSecret.take(12) + &quot;...&quot;&#10;            status = &quot;File selected: $fileName. Share the QR code or secret with receiver.&quot;&#10;&#10;            // Generate QR code&#10;            qrCodeBitmap = QRCodeHelper.generateQRCode(generatedSecret, 400)&#10;            showQRCode = true&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        wifiTransferHelper = WiFiTransferHelper(this)&#10;&#10;        // Register broadcast receiver for file transfer updates&#10;        val filter = IntentFilter(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            registerReceiver(fileTransferReceiver, filter, Context.RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            registerReceiver(fileTransferReceiver, filter)&#10;        }&#10;&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(innerPadding)&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Secure File Transfer&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)&#10;                    ) {&#10;                        Text(&#10;                            text = status,&#10;                            modifier = Modifier.padding(16.dp),&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            isSender = true&#10;                            resetState()&#10;                            status = &quot;Select a file to send&quot;&#10;                            pickFileLauncher.launch(&quot;*/*&quot;)&#10;                        },&#10;                        enabled = !waitingForSecret&#10;                    ) {&#10;                        Text(&quot;Send File&quot;)&#10;                    }&#10;&#10;                    Button(&#10;                        onClick = {&#10;                            isSender = false&#10;                            resetState()&#10;                            status = &quot;Select a directory to save received files&quot;&#10;                            // Open directory picker for receiver&#10;                            directoryPickerLauncher.launch(null)&#10;                        },&#10;                        enabled = !waitingForSecret&#10;                    ) {&#10;                        Text(&quot;Receive File&quot;)&#10;                    }&#10;&#10;                    if (displayedSecret.isNotEmpty()) {&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)&#10;                        ) {&#10;                            Column(&#10;                                modifier = Modifier.padding(16.dp),&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Secret Code:&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                Text(&#10;                                    text = displayedSecret,&#10;                                    style = MaterialTheme.typography.headlineSmall,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = MaterialTheme.colorScheme.primary&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Show this QR code to the receiver or verify codes match!&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    textAlign = TextAlign.Center&#10;                                )&#10;&#10;                                if (isSender &amp;&amp; qrCodeBitmap != null) {&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Button(&#10;                                        onClick = {&#10;                                            showQRCode = true&#10;                                        }&#10;                                    ) {&#10;                                        Text(&quot;Show QR Code&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Scan QR Code button for receivers&#10;                    if (waitingForSecret) {&#10;                        Button(&#10;                            onClick = {&#10;                                val options = ScanOptions().apply {&#10;                                    setPrompt(&quot;Scan the sender's QR code&quot;)&#10;                                    setBeepEnabled(true)&#10;                                    setOrientationLocked(false) // Allow rotation for better scanning&#10;                                    setBarcodeImageEnabled(true)&#10;                                    setDesiredBarcodeFormats(ScanOptions.QR_CODE)&#10;                                    setCameraId(0) // Use back camera&#10;                                    setTimeout(30000) // 30 second timeout&#10;                                }&#10;                                qrScannerLauncher.launch(options)&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Scan QR Code&quot;)&#10;                        }&#10;                    }&#10;&#10;                    if (waitingForSecret) {&#10;                        Button(&#10;                            onClick = {&#10;                                // Manual secret input&#10;                                showManualSecretDialog = true&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Enter Secret Manually&quot;)&#10;                        }&#10;                    }&#10;&#10;                    if (showConfirmDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {},&#10;                            title = { Text(&quot;Connection Verified&quot;) },&#10;                            text = { Text(&quot;Both devices have the same secret. Do the secret codes match on both screens before proceeding? Allow file transfer to proceed?&quot;) },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showConfirmDialog = false&#10;                                    startFileTransfer()&#10;                                }) { Text(&quot;Yes, Start Transfer&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showConfirmDialog = false&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;No, Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (showQRCode) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showQRCode = false&#10;                            },&#10;                            title = { Text(&quot;Share QR Code&quot;) },&#10;                            text = {&#10;                                Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                                    Text(&#10;                                        text = &quot;Show this QR code to the receiver to share the secret.&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium,&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(16.dp))&#10;                                    // QR code image&#10;                                    qrCodeBitmap?.let { bitmap -&gt;&#10;                                        Image(&#10;                                            bitmap = bitmap.asImageBitmap(),&#10;                                            contentDescription = &quot;QR Code&quot;,&#10;                                            modifier = Modifier.size(250.dp)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showQRCode = false&#10;                                    // Start WiFi transfer after showing QR code&#10;                                    startWifiTransfer()&#10;                                }) { Text(&quot;Continue&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showQRCode = false&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    if (showManualSecretDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showManualSecretDialog = false&#10;                            },&#10;                            title = { Text(&quot;Enter Secret Manually&quot;) },&#10;                            text = {&#10;                                Column {&#10;                                    Text(&#10;                                        text = &quot;Enter the complete secret code from the sender's device.&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    // Text field for manual secret input&#10;                                    TextField(&#10;                                        value = manualSecretInput,&#10;                                        onValueChange = { manualSecretInput = it },&#10;                                        label = { Text(&quot;Secret Code&quot;) },&#10;                                        singleLine = true,&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                }&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    // Verify and proceed with manual secret&#10;                                    if (manualSecretInput.length &gt;= 30) { // UUID length&#10;                                        handshakeSecret = manualSecretInput&#10;                                        displayedSecret = manualSecretInput.take(12)&#10;                                        status = &quot;Secret received! Connecting to sender...&quot;&#10;                                        showManualSecretDialog = false&#10;                                        waitingForSecret = false&#10;                                        manualSecretInput = &quot;&quot; // Clear the input&#10;                                        startWifiTransfer()&#10;                                    } else {&#10;                                        Toast.makeText(this@MainActivity, &quot;Please enter the complete secret code (should be around 36 characters)&quot;, Toast.LENGTH_LONG).show()&#10;                                    }&#10;                                }) { Text(&quot;Confirm Secret&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showManualSecretDialog = false&#10;                                    manualSecretInput = &quot;&quot; // Clear the input&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Show received file dialog&#10;                    if (showFileReceivedDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showFileReceivedDialog = false&#10;                            },&#10;                            title = { Text(&quot;File Received&quot;) },&#10;                            text = {&#10;                                Column {&#10;                                    Text(&#10;                                        text = &quot;The file has been received successfully.&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;File path: $receivedFilePath&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall,&#10;                                        textAlign = TextAlign.Start&#10;                                    )&#10;                                }&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showFileReceivedDialog = false&#10;                                }) { Text(&quot;OK&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Request permissions if not granted&#10;                    if (waitingForSecret &amp;&amp; !hasRequiredPermissions()) {&#10;                        LaunchedEffect(Unit) {&#10;                            // Show permission rationale and request permissions&#10;                            showPermissionDialog = true&#10;                        }&#10;                    }&#10;&#10;                    if (showPermissionDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showPermissionDialog = false&#10;                            },&#10;                            title = { Text(&quot;Permissions Required&quot;) },&#10;                            text = {&#10;                                Text(&#10;                                    text = &quot;This app requires certain permissions to be granted for file transfer to work. Please allow the required permissions.&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(onClick = {&#10;                                    showPermissionDialog = false&#10;                                    // Request permissions&#10;                                    requestRequiredPermissions()&#10;                                }) { Text(&quot;Grant Permissions&quot;) }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(onClick = {&#10;                                    showPermissionDialog = false&#10;                                    resetToIdle()&#10;                                }) { Text(&quot;Cancel&quot;) }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetState() {&#10;        handshakeSecret = null&#10;        displayedSecret = &quot;&quot;&#10;        selectedFileUri = null&#10;        peerIpAddress = null&#10;    }&#10;&#10;    private fun resetToIdle() {&#10;        waitingForSecret = false&#10;        showConfirmDialog = false&#10;        status = &quot;Ready to start secure file transfer&quot;&#10;        isSender = false&#10;        resetState()&#10;    }&#10;&#10;    private fun getFileNameFromUri(context: Context, uri: Uri): String? {&#10;        val cursor = context.contentResolver.query(uri, null, null, null, null)&#10;        return cursor?.use {&#10;            if (it.moveToFirst()) {&#10;                val index = it.getColumnIndex(OpenableColumns.DISPLAY_NAME)&#10;                if (index &gt;= 0) it.getString(index) else null&#10;            } else null&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        unregisterReceiver(fileTransferReceiver)&#10;        wifiTransferHelper.cleanup()&#10;    }&#10;&#10;    // WiFiTransferHelper.TransferListener implementation&#10;    override fun onTransferProgress(bytesTransferred: Long, totalBytes: Long) {&#10;        runOnUiThread {&#10;            val progress = (bytesTransferred * 100 / totalBytes).toInt()&#10;            status = &quot;Transfer progress: $progress%&quot;&#10;        }&#10;    }&#10;&#10;    override fun onTransferComplete(success: Boolean, message: String) {&#10;        runOnUiThread {&#10;            status = message&#10;            if (success) {&#10;                Toast.makeText(this, &quot;Transfer completed successfully!&quot;, Toast.LENGTH_LONG).show()&#10;                resetToIdle()&#10;            } else {&#10;                Toast.makeText(this, &quot;Transfer failed: $message&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onPeerDiscovered(peerIp: String) {&#10;        runOnUiThread {&#10;            status = &quot;Found peer device on network: $peerIp&quot;&#10;        }&#10;    }&#10;&#10;    override fun onConnectionEstablished(peerIp: String) {&#10;        runOnUiThread {&#10;            peerIpAddress = peerIp&#10;            status = &quot;Connected to peer device. Verifying secrets...&quot;&#10;            showConfirmDialog = true&#10;        }&#10;    }&#10;&#10;    private fun startWifiTransfer() {&#10;        if (handshakeSecret != null) {&#10;            wifiTransferHelper.setTransferListener(this)&#10;            if (isSender) {&#10;                status = &quot;Starting as sender. Looking for receiver...&quot;&#10;                wifiTransferHelper.startSender(handshakeSecret!!)&#10;            } else {&#10;                status = &quot;Starting as receiver. Looking for sender...&quot;&#10;                wifiTransferHelper.startReceiver(handshakeSecret!!)&#10;                // Don't start file receiver here - wait for connection to be established&#10;                // It will be started in startFileTransfer() with the correct save directory&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startFileTransfer() {&#10;        if (isSender) {&#10;            if (selectedFileUri == null || peerIpAddress == null) {&#10;                status = &quot;Missing file or peer connection&quot;&#10;                return&#10;            }&#10;&#10;            val filePath = copyUriToCache(selectedFileUri!!)&#10;            if (filePath == null) {&#10;                status = &quot;Failed to prepare file for transfer&quot;&#10;                return&#10;            }&#10;&#10;            status = &quot;Sending encrypted file...&quot;&#10;            wifiTransferHelper.sendFile(filePath, peerIpAddress!!)&#10;        } else {&#10;            status = &quot;Ready to receive encrypted file...&quot;&#10;            // Pass the selected directory to the file receiver&#10;            wifiTransferHelper.startFileReceiver(selectedSaveDirectory)&#10;        }&#10;    }&#10;&#10;    private fun copyUriToCache(uri: Uri): String? {&#10;        return try {&#10;            val fileName = getFileNameFromUri(this, uri) ?: &quot;tempfile&quot;&#10;            val file = File(cacheDir, fileName)&#10;            contentResolver.openInputStream(uri)?.use { input -&gt;&#10;                java.io.FileOutputStream(file).use { output -&gt;&#10;                    input.copyTo(output)&#10;                }&#10;            }&#10;            file.absolutePath&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    fun onSecretVerified(groupOwnerAddress: String?) {&#10;        runOnUiThread {&#10;            if (isSender &amp;&amp; groupOwnerAddress != null) {&#10;                this@MainActivity.peerIpAddress = groupOwnerAddress&#10;            }&#10;            status = &quot;Connection established! Secrets match.&quot;&#10;            showConfirmDialog = true&#10;        }&#10;    }&#10;&#10;    fun onSecretRejected() {&#10;        runOnUiThread {&#10;            status = &quot;Secret verification failed! Connection rejected for security.&quot;&#10;            Toast.makeText(this@MainActivity, &quot;Security check failed - secrets don't match!&quot;, Toast.LENGTH_LONG).show()&#10;            resetToIdle()&#10;        }&#10;    }&#10;&#10;    private fun requestRequiredPermissions() {&#10;        val permissions = mutableListOf&lt;String&gt;()&#10;&#10;        // Add permissions based on Android version&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            permissions.addAll(listOf(&#10;                Manifest.permission.READ_MEDIA_IMAGES,&#10;                Manifest.permission.READ_MEDIA_VIDEO,&#10;                Manifest.permission.READ_MEDIA_AUDIO,&#10;                Manifest.permission.CAMERA&#10;            ))&#10;        } else {&#10;            permissions.addAll(listOf(&#10;                Manifest.permission.READ_EXTERNAL_STORAGE,&#10;                Manifest.permission.WRITE_EXTERNAL_STORAGE,&#10;                Manifest.permission.CAMERA&#10;            ))&#10;        }&#10;&#10;        permissions.addAll(listOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        ))&#10;&#10;        permissionLauncher.launch(permissions.toTypedArray())&#10;    }&#10;&#10;    private fun hasRequiredPermissions(): Boolean {&#10;        val cameraPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED&#10;        val locationPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED&#10;        val wifiPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_WIFI_STATE) == PackageManager.PERMISSION_GRANTED&#10;&#10;        val storagePermission = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES) == PackageManager.PERMISSION_GRANTED&#10;        } else {&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        return cameraPermission &amp;&amp; locationPermission &amp;&amp; wifiPermission &amp;&amp; storagePermission&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/WiFiTransferHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/WiFiTransferHelper.kt" />
              <option name="originalContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.io.*&#10;import java.net.*&#10;import java.util.concurrent.Executors&#10;&#10;class WiFiTransferHelper(private val context: Context) {&#10;&#10;    interface TransferListener {&#10;        fun onTransferProgress(bytesTransferred: Long, totalBytes: Long)&#10;        fun onTransferComplete(success: Boolean, message: String)&#10;        fun onPeerDiscovered(peerIp: String)&#10;        fun onConnectionEstablished(peerIp: String)&#10;    }&#10;&#10;    private var transferListener: TransferListener? = null&#10;    private var discoverySocket: DatagramSocket? = null&#10;    private var secretServerSocket: ServerSocket? = null&#10;    private var fileServerSocket: ServerSocket? = null&#10;    private var currentSecret: String? = null&#10;    private val executor = Executors.newCachedThreadPool()&#10;    private var isRunning = false&#10;    private var isSender = false&#10;&#10;    companion object {&#10;        private const val DISCOVERY_PORT = 8987&#10;        private const val SECRET_VERIFICATION_PORT = 8988&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;        private const val BROADCAST_MESSAGE = &quot;NFConnect_Discovery&quot;&#10;    }&#10;&#10;    fun setTransferListener(listener: TransferListener) {&#10;        this.transferListener = listener&#10;    }&#10;&#10;    fun startSender(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = true&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting sender with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Start discovery server to respond to receiver's broadcast&#10;        executor.submit {&#10;            startDiscoveryServer()&#10;        }&#10;&#10;        // Start secret verification server&#10;        executor.submit {&#10;            startSecretVerificationServer()&#10;        }&#10;    }&#10;&#10;    fun startReceiver(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = false&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting receiver with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Small delay to ensure sender is ready&#10;        Thread.sleep(2000)&#10;&#10;        // Start discovery by broadcasting&#10;        executor.submit {&#10;            discoverSender()&#10;        }&#10;    }&#10;&#10;    private fun startDiscoveryServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            discoverySocket?.close()&#10;&#10;            discoverySocket = DatagramSocket(DISCOVERY_PORT)&#10;            discoverySocket?.soTimeout = 30000 // 30 second timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server listening on port $DISCOVERY_PORT&quot;)&#10;            val buffer = ByteArray(1024)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val packet = DatagramPacket(buffer, buffer.size)&#10;                    discoverySocket?.receive(packet)&#10;&#10;                    val message = String(packet.data, 0, packet.length)&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received discovery message: $message&quot;)&#10;&#10;                    if (message.startsWith(BROADCAST_MESSAGE)) {&#10;                        // Respond to discovery request&#10;                        val response = &quot;NFConnect_Response:${currentSecret?.take(8)}&quot;&#10;                        val responsePacket = DatagramPacket(&#10;                            response.toByteArray(),&#10;                            response.length,&#10;                            packet.address,&#10;                            packet.port&#10;                        )&#10;                        discoverySocket?.send(responsePacket)&#10;&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Responded to discovery from ${packet.address.hostAddress}&quot;)&#10;                        transferListener?.onPeerDiscovered(packet.address.hostAddress)&#10;&#10;                        // Break after first successful response to avoid conflicts&#10;                        break&#10;                    }&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start discovery server: ${e.message}&quot;)&#10;        } finally {&#10;            discoverySocket?.close()&#10;        }&#10;    }&#10;&#10;    private fun discoverSender() {&#10;        try {&#10;            val socket = DatagramSocket()&#10;            socket.broadcast = true&#10;            socket.soTimeout = 5000 // 5 second timeout per attempt&#10;&#10;            val message = &quot;$BROADCAST_MESSAGE:${currentSecret?.take(8)}&quot;&#10;            val buffer = message.toByteArray()&#10;&#10;            // Try to discover on multiple network addresses&#10;            val addresses = listOf(&#10;                &quot;255.255.255.255&quot;,&#10;                &quot;192.168.1.255&quot;,&#10;                &quot;192.168.0.255&quot;,&#10;                &quot;10.0.0.255&quot;&#10;            )&#10;&#10;            var found = false&#10;&#10;            for (attempt in 1..5) {&#10;                if (found) break&#10;&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery attempt $attempt&quot;)&#10;&#10;                for (addressString in addresses) {&#10;                    try {&#10;                        val broadcast = InetAddress.getByName(addressString)&#10;                        val packet = DatagramPacket(buffer, buffer.size, broadcast, DISCOVERY_PORT)&#10;                        socket.send(packet)&#10;&#10;                        // Listen for response&#10;                        val responseBuffer = ByteArray(1024)&#10;                        val responsePacket = DatagramPacket(responseBuffer, responseBuffer.size)&#10;                        socket.receive(responsePacket)&#10;&#10;                        val response = String(responsePacket.data, 0, responsePacket.length)&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received response: $response&quot;)&#10;&#10;                        if (response.startsWith(&quot;NFConnect_Response&quot;)) {&#10;                            val senderIp = responsePacket.address.hostAddress&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Found sender at: $senderIp&quot;)&#10;                            transferListener?.onPeerDiscovered(senderIp)&#10;&#10;                            // Small delay before verification&#10;                            Thread.sleep(1000)&#10;&#10;                            // Attempt secret verification&#10;                            verifySecretWithSender(senderIp)&#10;                            found = true&#10;                            break&#10;                        }&#10;                    } catch (e: SocketTimeoutException) {&#10;                        // Try next address&#10;                        continue&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error with address $addressString: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                if (!found) {&#10;                    Thread.sleep(2000) // Wait before next attempt&#10;                }&#10;            }&#10;&#10;            socket.close()&#10;&#10;            if (!found) {&#10;                transferListener?.onTransferComplete(false, &quot;Could not find sender device&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Discovery failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startSecretVerificationServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            secretServerSocket?.close()&#10;&#10;            secretServerSocket = ServerSocket(SECRET_VERIFICATION_PORT)&#10;            secretServerSocket?.soTimeout = 60000 // 1 minute timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server listening on port $SECRET_VERIFICATION_PORT&quot;)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val client = secretServerSocket?.accept() ?: break&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Client connected for secret verification&quot;)&#10;&#10;                    executor.submit {&#10;                        handleSecretVerification(client)&#10;                    }&#10;&#10;                    // Only handle one verification to avoid conflicts&#10;                    break&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start secret verification server: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleSecretVerification(client: Socket) {&#10;        try {&#10;            client.soTimeout = 10000 // 10 second timeout&#10;            val input = BufferedReader(InputStreamReader(client.getInputStream()))&#10;            val output = PrintWriter(client.getOutputStream(), true)&#10;&#10;            val receivedSecret = input.readLine()&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received secret verification: ${receivedSecret?.take(8)}...&quot;)&#10;&#10;            if (receivedSecret == currentSecret) {&#10;                output.println(&quot;SECRET_VERIFIED&quot;)&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onConnectionEstablished(client.inetAddress.hostAddress)&#10;            } else {&#10;                output.println(&quot;SECRET_REJECTED&quot;)&#10;                Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected from client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Secret mismatch - security check failed&quot;)&#10;            }&#10;&#10;            client.close()&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Secret verification failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun verifySecretWithSender(senderIp: String) {&#10;        executor.submit {&#10;            try {&#10;                // Multiple connection attempts with delays&#10;                var connected = false&#10;&#10;                for (attempt in 1..3) {&#10;                    try {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt to $senderIp&quot;)&#10;&#10;                        val socket = Socket()&#10;                        socket.connect(InetSocketAddress(senderIp, SECRET_VERIFICATION_PORT), 10000)&#10;                        socket.soTimeout = 10000&#10;&#10;                        val output = PrintWriter(socket.getOutputStream(), true)&#10;                        val input = BufferedReader(InputStreamReader(socket.getInputStream()))&#10;&#10;                        output.println(currentSecret)&#10;                        val response = input.readLine()&#10;&#10;                        if (response == &quot;SECRET_VERIFIED&quot;) {&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with sender&quot;)&#10;                            transferListener?.onConnectionEstablished(senderIp)&#10;                            connected = true&#10;                            socket.close()&#10;                            break&#10;                        } else {&#10;                            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected by sender: $response&quot;)&#10;                            socket.close()&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt failed: ${e.message}&quot;)&#10;                        if (attempt &lt; 3) {&#10;                            Thread.sleep(2000) // Wait before retry&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (!connected) {&#10;                    transferListener?.onTransferComplete(false, &quot;Secret verification failed after multiple attempts&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Connection failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendFile(filePath: String, peerIp: String) {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for encryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file transfer to $peerIp&quot;)&#10;&#10;        // Use updated FileTransferService&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_SEND_FILE,&#10;            filePath = filePath,&#10;            hostAddress = peerIp,&#10;            secret = currentSecret!!&#10;        )&#10;    }&#10;&#10;    fun startFileReceiver() {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for decryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file receiver&quot;)&#10;&#10;        // Use updated FileTransferService&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_RECEIVE_FILE,&#10;            secret = currentSecret!!&#10;        )&#10;    }&#10;&#10;    fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            discoverySocket?.close()&#10;            secretServerSocket?.close()&#10;            fileServerSocket?.close()&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error during cleanup: ${e.message}&quot;)&#10;        }&#10;        executor.shutdown()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.util.Log&#10;import java.io.*&#10;import java.net.*&#10;import java.util.concurrent.Executors&#10;&#10;class WiFiTransferHelper(private val context: Context) {&#10;&#10;    interface TransferListener {&#10;        fun onTransferProgress(bytesTransferred: Long, totalBytes: Long)&#10;        fun onTransferComplete(success: Boolean, message: String)&#10;        fun onPeerDiscovered(peerIp: String)&#10;        fun onConnectionEstablished(peerIp: String)&#10;    }&#10;&#10;    private var transferListener: TransferListener? = null&#10;    private var discoverySocket: DatagramSocket? = null&#10;    private var secretServerSocket: ServerSocket? = null&#10;    private var fileServerSocket: ServerSocket? = null&#10;    private var currentSecret: String? = null&#10;    private val executor = Executors.newCachedThreadPool()&#10;    private var isRunning = false&#10;    private var isSender = false&#10;&#10;    companion object {&#10;        private const val DISCOVERY_PORT = 8987&#10;        private const val SECRET_VERIFICATION_PORT = 8988&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;        private const val BROADCAST_MESSAGE = &quot;NFConnect_Discovery&quot;&#10;    }&#10;&#10;    fun setTransferListener(listener: TransferListener) {&#10;        this.transferListener = listener&#10;    }&#10;&#10;    fun startSender(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = true&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting sender with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Start discovery server to respond to receiver's broadcast&#10;        executor.submit {&#10;            startDiscoveryServer()&#10;        }&#10;&#10;        // Start secret verification server&#10;        executor.submit {&#10;            startSecretVerificationServer()&#10;        }&#10;    }&#10;&#10;    fun startReceiver(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = false&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting receiver with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Small delay to ensure sender is ready&#10;        Thread.sleep(2000)&#10;&#10;        // Start discovery by broadcasting&#10;        executor.submit {&#10;            discoverSender()&#10;        }&#10;    }&#10;&#10;    private fun startDiscoveryServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            discoverySocket?.close()&#10;&#10;            discoverySocket = DatagramSocket(DISCOVERY_PORT)&#10;            discoverySocket?.soTimeout = 30000 // 30 second timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server listening on port $DISCOVERY_PORT&quot;)&#10;            val buffer = ByteArray(1024)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val packet = DatagramPacket(buffer, buffer.size)&#10;                    discoverySocket?.receive(packet)&#10;&#10;                    val message = String(packet.data, 0, packet.length)&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received discovery message: $message&quot;)&#10;&#10;                    if (message.startsWith(BROADCAST_MESSAGE)) {&#10;                        // Respond to discovery request&#10;                        val response = &quot;NFConnect_Response:${currentSecret?.take(8)}&quot;&#10;                        val responsePacket = DatagramPacket(&#10;                            response.toByteArray(),&#10;                            response.length,&#10;                            packet.address,&#10;                            packet.port&#10;                        )&#10;                        discoverySocket?.send(responsePacket)&#10;&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Responded to discovery from ${packet.address.hostAddress}&quot;)&#10;                        transferListener?.onPeerDiscovered(packet.address.hostAddress)&#10;&#10;                        // Break after first successful response to avoid conflicts&#10;                        break&#10;                    }&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start discovery server: ${e.message}&quot;)&#10;        } finally {&#10;            discoverySocket?.close()&#10;        }&#10;    }&#10;&#10;    private fun discoverSender() {&#10;        try {&#10;            val socket = DatagramSocket()&#10;            socket.broadcast = true&#10;            socket.soTimeout = 5000 // 5 second timeout per attempt&#10;&#10;            val message = &quot;$BROADCAST_MESSAGE:${currentSecret?.take(8)}&quot;&#10;            val buffer = message.toByteArray()&#10;&#10;            // Try to discover on multiple network addresses&#10;            val addresses = listOf(&#10;                &quot;255.255.255.255&quot;,&#10;                &quot;192.168.1.255&quot;,&#10;                &quot;192.168.0.255&quot;,&#10;                &quot;10.0.0.255&quot;&#10;            )&#10;&#10;            var found = false&#10;&#10;            for (attempt in 1..5) {&#10;                if (found) break&#10;&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery attempt $attempt&quot;)&#10;&#10;                for (addressString in addresses) {&#10;                    try {&#10;                        val broadcast = InetAddress.getByName(addressString)&#10;                        val packet = DatagramPacket(buffer, buffer.size, broadcast, DISCOVERY_PORT)&#10;                        socket.send(packet)&#10;&#10;                        // Listen for response&#10;                        val responseBuffer = ByteArray(1024)&#10;                        val responsePacket = DatagramPacket(responseBuffer, responseBuffer.size)&#10;                        socket.receive(responsePacket)&#10;&#10;                        val response = String(responsePacket.data, 0, responsePacket.length)&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received response: $response&quot;)&#10;&#10;                        if (response.startsWith(&quot;NFConnect_Response&quot;)) {&#10;                            val senderIp = responsePacket.address.hostAddress&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Found sender at: $senderIp&quot;)&#10;                            transferListener?.onPeerDiscovered(senderIp)&#10;&#10;                            // Small delay before verification&#10;                            Thread.sleep(1000)&#10;&#10;                            // Attempt secret verification&#10;                            verifySecretWithSender(senderIp)&#10;                            found = true&#10;                            break&#10;                        }&#10;                    } catch (e: SocketTimeoutException) {&#10;                        // Try next address&#10;                        continue&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error with address $addressString: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                if (!found) {&#10;                    Thread.sleep(2000) // Wait before next attempt&#10;                }&#10;            }&#10;&#10;            socket.close()&#10;&#10;            if (!found) {&#10;                transferListener?.onTransferComplete(false, &quot;Could not find sender device&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Discovery failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startSecretVerificationServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            secretServerSocket?.close()&#10;&#10;            secretServerSocket = ServerSocket(SECRET_VERIFICATION_PORT)&#10;            secretServerSocket?.soTimeout = 60000 // 1 minute timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server listening on port $SECRET_VERIFICATION_PORT&quot;)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val client = secretServerSocket?.accept() ?: break&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Client connected for secret verification&quot;)&#10;&#10;                    executor.submit {&#10;                        handleSecretVerification(client)&#10;                    }&#10;&#10;                    // Only handle one verification to avoid conflicts&#10;                    break&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start secret verification server: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleSecretVerification(client: Socket) {&#10;        try {&#10;            client.soTimeout = 10000 // 10 second timeout&#10;            val input = BufferedReader(InputStreamReader(client.getInputStream()))&#10;            val output = PrintWriter(client.getOutputStream(), true)&#10;&#10;            val receivedSecret = input.readLine()&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received secret verification: ${receivedSecret?.take(8)}...&quot;)&#10;&#10;            if (receivedSecret == currentSecret) {&#10;                output.println(&quot;SECRET_VERIFIED&quot;)&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onConnectionEstablished(client.inetAddress.hostAddress)&#10;            } else {&#10;                output.println(&quot;SECRET_REJECTED&quot;)&#10;                Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected from client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Secret mismatch - security check failed&quot;)&#10;            }&#10;&#10;            client.close()&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Secret verification failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun verifySecretWithSender(senderIp: String) {&#10;        executor.submit {&#10;            try {&#10;                // Multiple connection attempts with delays&#10;                var connected = false&#10;&#10;                for (attempt in 1..3) {&#10;                    try {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt to $senderIp&quot;)&#10;&#10;                        val socket = Socket()&#10;                        socket.connect(InetSocketAddress(senderIp, SECRET_VERIFICATION_PORT), 10000)&#10;                        socket.soTimeout = 10000&#10;&#10;                        val output = PrintWriter(socket.getOutputStream(), true)&#10;                        val input = BufferedReader(InputStreamReader(socket.getInputStream()))&#10;&#10;                        output.println(currentSecret)&#10;                        val response = input.readLine()&#10;&#10;                        if (response == &quot;SECRET_VERIFIED&quot;) {&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with sender&quot;)&#10;                            transferListener?.onConnectionEstablished(senderIp)&#10;                            connected = true&#10;                            socket.close()&#10;                            break&#10;                        } else {&#10;                            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected by sender: $response&quot;)&#10;                            socket.close()&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt failed: ${e.message}&quot;)&#10;                        if (attempt &lt; 3) {&#10;                            Thread.sleep(2000) // Wait before retry&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (!connected) {&#10;                    transferListener?.onTransferComplete(false, &quot;Secret verification failed after multiple attempts&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Connection failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendFile(filePath: String, peerIp: String) {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for encryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file transfer to $peerIp&quot;)&#10;&#10;        // Use updated FileTransferService&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_SEND_FILE,&#10;            filePath = filePath,&#10;            hostAddress = peerIp,&#10;            secret = currentSecret!!&#10;        )&#10;    }&#10;&#10;    fun startFileReceiver(saveDirectory: Uri? = null) {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for decryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file receiver&quot;)&#10;&#10;        // Use updated FileTransferService with save directory&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_RECEIVE_FILE,&#10;            secret = currentSecret!!,&#10;            saveDirectoryUri = saveDirectory&#10;        )&#10;    }&#10;&#10;    fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            discoverySocket?.close()&#10;            secretServerSocket?.close()&#10;            fileServerSocket?.close()&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error during cleanup: ${e.message}&quot;)&#10;        }&#10;        executor.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/file_paths.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/file_paths.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;external-files-path name=&quot;my_images&quot; path=&quot;Documents/&quot; /&gt;&#10;    &lt;external-files-path name=&quot;my_downloads&quot; path=&quot;Downloads/&quot; /&gt;&#10;    &lt;external-path name=&quot;external_storage&quot; path=&quot;.&quot; /&gt;&#10;&lt;/paths&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>