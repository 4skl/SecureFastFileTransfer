<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- WiFi and Network permissions for file transfer --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- File access permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;&#10;    &lt;!-- Camera permission for QR code scanning --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;!-- Android 13+ permissions for nearby devices --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.NEARBY_WIFI_DEVICES&quot; /&gt;&#10;&#10;    &lt;!-- Required for Camera (QR code scanning) --&gt;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- FileTransferService for encrypted file transfers --&gt;&#10;        &lt;service android:name=&quot;.FileTransferService&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- WiFi and Network permissions for file transfer --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- File access permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#10;                     android:maxSdkVersion=&quot;32&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#10;                     android:maxSdkVersion=&quot;29&quot; /&gt;&#10;    &#10;    &lt;!-- Android 13+ permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot; &#10;                     tools:ignore=&quot;ScopedStorage&quot; /&gt;&#10;&#10;    &lt;!-- Camera permission for QR code scanning --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;!-- Android 13+ permissions for nearby devices --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.NEARBY_WIFI_DEVICES&quot; /&gt;&#10;&#10;    &lt;!-- Required for Camera (QR code scanning) --&gt;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:requestLegacyExternalStorage=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- FileTransferService for encrypted file transfers --&gt;&#10;        &lt;service android:name=&quot;.FileTransferService&quot; /&gt;&#10;&#10;        &lt;!-- File provider for secure file access --&gt;&#10;        &lt;provider&#10;            android:name=&quot;androidx.core.content.FileProvider&quot;&#10;            android:authorities=&quot;${applicationId}.fileprovider&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:grantUriPermissions=&quot;true&quot;&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;&#10;                android:resource=&quot;@xml/file_paths&quot; /&gt;&#10;        &lt;/provider&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/FileTransferService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/FileTransferService.kt" />
              <option name="originalContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.app.IntentService&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.io.*&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class FileTransferService : IntentService(&quot;FileTransferService&quot;) {&#10;&#10;    companion object {&#10;        const val ACTION_SEND_FILE = &quot;com.skl.nfconnect.SEND_FILE&quot;&#10;        const val ACTION_RECEIVE_FILE = &quot;com.skl.nfconnect.RECEIVE_FILE&quot;&#10;        const val EXTRA_FILE_PATH = &quot;file_path&quot;&#10;        const val EXTRA_HOST = &quot;host_address&quot;&#10;        const val EXTRA_SECRET = &quot;shared_secret&quot;&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;&#10;        fun startService(context: Context, action: String, filePath: String? = null, hostAddress: String? = null, secret: String) {&#10;            val intent = Intent(context, FileTransferService::class.java).apply {&#10;                this.action = action&#10;                putExtra(EXTRA_SECRET, secret)&#10;                filePath?.let { putExtra(EXTRA_FILE_PATH, it) }&#10;                hostAddress?.let { putExtra(EXTRA_HOST, it) }&#10;            }&#10;            context.startService(intent)&#10;        }&#10;    }&#10;&#10;    override fun onHandleIntent(intent: Intent?) {&#10;        intent ?: return&#10;&#10;        when (intent.action) {&#10;            ACTION_SEND_FILE -&gt; {&#10;                val filePath = intent.getStringExtra(EXTRA_FILE_PATH)&#10;                val hostAddress = intent.getStringExtra(EXTRA_HOST)&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                if (filePath != null &amp;&amp; hostAddress != null &amp;&amp; secret != null) {&#10;                    sendFile(filePath, hostAddress, secret)&#10;                }&#10;            }&#10;            ACTION_RECEIVE_FILE -&gt; {&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                if (secret != null) {&#10;                    receiveFile(secret)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendFile(filePath: String, hostAddress: String, secret: String) {&#10;        try {&#10;            val file = File(filePath)&#10;            val fileBytes = file.readBytes()&#10;&#10;            // Encrypt the file using the shared secret&#10;            val encryptedData = CryptoHelper.encryptFile(fileBytes, secret)&#10;            if (encryptedData == null) {&#10;                throw Exception(&quot;Failed to encrypt file&quot;)&#10;            }&#10;&#10;            val socket = Socket(hostAddress, FILE_TRANSFER_PORT)&#10;            val outputStream = socket.getOutputStream()&#10;            val dataOutputStream = DataOutputStream(outputStream)&#10;&#10;            // Send file name first&#10;            dataOutputStream.writeUTF(file.name)&#10;            // Send encrypted data size&#10;            dataOutputStream.writeLong(encryptedData.data.size.toLong())&#10;            // Send IV size and IV&#10;            dataOutputStream.writeInt(encryptedData.iv.size)&#10;            dataOutputStream.write(encryptedData.iv)&#10;&#10;            // Send encrypted file data&#10;            dataOutputStream.write(encryptedData.data)&#10;&#10;            dataOutputStream.close()&#10;            socket.close()&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Encrypted file sent successfully: ${file.name}&quot;)&#10;&#10;            // Broadcast success&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File sent successfully&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error sending file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to send file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;&#10;    private fun receiveFile(secret: String) {&#10;        try {&#10;            val serverSocket = ServerSocket(FILE_TRANSFER_PORT)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Waiting for encrypted file transfer...&quot;)&#10;&#10;            val socket = serverSocket.accept()&#10;            val inputStream = socket.getInputStream()&#10;            val dataInputStream = DataInputStream(inputStream)&#10;&#10;            // Receive file name&#10;            val fileName = dataInputStream.readUTF()&#10;            // Receive encrypted data size&#10;            val encryptedSize = dataInputStream.readLong()&#10;            // Receive IV&#10;            val ivSize = dataInputStream.readInt()&#10;            val iv = ByteArray(ivSize)&#10;            dataInputStream.readFully(iv)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Receiving encrypted file: $fileName, size: $encryptedSize bytes&quot;)&#10;&#10;            // Receive encrypted data&#10;            val encryptedData = ByteArray(encryptedSize.toInt())&#10;            dataInputStream.readFully(encryptedData)&#10;&#10;            dataInputStream.close()&#10;            serverSocket.close()&#10;&#10;            // Decrypt the file&#10;            val encryptedFileData = CryptoHelper.EncryptedData(encryptedData, iv)&#10;            val decryptedBytes = CryptoHelper.decryptFile(encryptedFileData, secret)&#10;&#10;            if (decryptedBytes == null) {&#10;                throw Exception(&quot;Failed to decrypt file - incorrect secret or corrupted data&quot;)&#10;            }&#10;&#10;            // Save decrypted file to Downloads directory&#10;            val downloadsDir = File(getExternalFilesDir(null), &quot;Downloads&quot;)&#10;            if (!downloadsDir.exists()) {&#10;                downloadsDir.mkdirs()&#10;            }&#10;            val receivedFile = File(downloadsDir, fileName)&#10;            receivedFile.writeBytes(decryptedBytes)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File decrypted and saved successfully: $fileName&quot;)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to: ${receivedFile.absolutePath}&quot;)&#10;&#10;            // Broadcast success with file path&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File received and decrypted successfully: $fileName&quot;)&#10;            broadcastIntent.putExtra(&quot;file_path&quot;, receivedFile.absolutePath)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error receiving file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.nfconnect.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to receive file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.app.IntentService&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.documentfile.provider.DocumentFile&#10;import java.io.*&#10;import java.net.ServerSocket&#10;import java.net.Socket&#10;&#10;class FileTransferService : IntentService(&quot;FileTransferService&quot;) {&#10;&#10;    companion object {&#10;        const val ACTION_SEND_FILE = &quot;com.skl.securefastfiletransfer.SEND_FILE&quot;&#10;        const val ACTION_RECEIVE_FILE = &quot;com.skl.securefastfiletransfer.RECEIVE_FILE&quot;&#10;        const val EXTRA_FILE_PATH = &quot;file_path&quot;&#10;        const val EXTRA_HOST = &quot;host_address&quot;&#10;        const val EXTRA_SECRET = &quot;shared_secret&quot;&#10;        const val EXTRA_SAVE_DIRECTORY_URI = &quot;save_directory_uri&quot;&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;&#10;        fun startService(&#10;            context: Context,&#10;            action: String,&#10;            filePath: String? = null,&#10;            hostAddress: String? = null,&#10;            secret: String,&#10;            saveDirectoryUri: Uri? = null&#10;        ) {&#10;            val intent = Intent(context, FileTransferService::class.java).apply {&#10;                this.action = action&#10;                putExtra(EXTRA_SECRET, secret)&#10;                filePath?.let { putExtra(EXTRA_FILE_PATH, it) }&#10;                hostAddress?.let { putExtra(EXTRA_HOST, it) }&#10;                saveDirectoryUri?.let { putExtra(EXTRA_SAVE_DIRECTORY_URI, it.toString()) }&#10;            }&#10;            context.startService(intent)&#10;        }&#10;    }&#10;&#10;    override fun onHandleIntent(intent: Intent?) {&#10;        intent ?: return&#10;&#10;        when (intent.action) {&#10;            ACTION_SEND_FILE -&gt; {&#10;                val filePath = intent.getStringExtra(EXTRA_FILE_PATH)&#10;                val hostAddress = intent.getStringExtra(EXTRA_HOST)&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                if (filePath != null &amp;&amp; hostAddress != null &amp;&amp; secret != null) {&#10;                    sendFile(filePath, hostAddress, secret)&#10;                }&#10;            }&#10;            ACTION_RECEIVE_FILE -&gt; {&#10;                val secret = intent.getStringExtra(EXTRA_SECRET)&#10;                val saveDirectoryUriString = intent.getStringExtra(EXTRA_SAVE_DIRECTORY_URI)&#10;                val saveDirectoryUri = saveDirectoryUriString?.let { Uri.parse(it) }&#10;                if (secret != null) {&#10;                    receiveFile(secret, saveDirectoryUri)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendFile(filePath: String, hostAddress: String, secret: String) {&#10;        try {&#10;            val file = File(filePath)&#10;            val fileBytes = file.readBytes()&#10;&#10;            // Encrypt the file using the shared secret&#10;            val encryptedData = CryptoHelper.encryptFile(fileBytes, secret)&#10;            if (encryptedData == null) {&#10;                throw Exception(&quot;Failed to encrypt file&quot;)&#10;            }&#10;&#10;            val socket = Socket(hostAddress, FILE_TRANSFER_PORT)&#10;            val outputStream = socket.getOutputStream()&#10;            val dataOutputStream = DataOutputStream(outputStream)&#10;&#10;            // Send file name first&#10;            dataOutputStream.writeUTF(file.name)&#10;            // Send encrypted data size&#10;            dataOutputStream.writeLong(encryptedData.data.size.toLong())&#10;            // Send IV size and IV&#10;            dataOutputStream.writeInt(encryptedData.iv.size)&#10;            dataOutputStream.write(encryptedData.iv)&#10;&#10;            // Send encrypted file data&#10;            dataOutputStream.write(encryptedData.data)&#10;&#10;            dataOutputStream.close()&#10;            socket.close()&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Encrypted file sent successfully: ${file.name}&quot;)&#10;&#10;            // Broadcast success with consistent action&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File sent successfully&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error sending file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to send file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;&#10;    private fun receiveFile(secret: String, saveDirectoryUri: Uri?) {&#10;        try {&#10;            val serverSocket = ServerSocket(FILE_TRANSFER_PORT)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Waiting for encrypted file transfer...&quot;)&#10;&#10;            val socket = serverSocket.accept()&#10;            val inputStream = socket.getInputStream()&#10;            val dataInputStream = DataInputStream(inputStream)&#10;&#10;            // Receive file name&#10;            val fileName = dataInputStream.readUTF()&#10;            // Receive encrypted data size&#10;            val encryptedSize = dataInputStream.readLong()&#10;            // Receive IV&#10;            val ivSize = dataInputStream.readInt()&#10;            val iv = ByteArray(ivSize)&#10;            dataInputStream.readFully(iv)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Receiving encrypted file: $fileName, size: $encryptedSize bytes&quot;)&#10;&#10;            // Receive encrypted data&#10;            val encryptedData = ByteArray(encryptedSize.toInt())&#10;            dataInputStream.readFully(encryptedData)&#10;&#10;            dataInputStream.close()&#10;            serverSocket.close()&#10;&#10;            // Decrypt the file&#10;            val encryptedFileData = CryptoHelper.EncryptedData(encryptedData, iv)&#10;            val decryptedBytes = CryptoHelper.decryptFile(encryptedFileData, secret)&#10;&#10;            if (decryptedBytes == null) {&#10;                throw Exception(&quot;Failed to decrypt file - incorrect secret or corrupted data&quot;)&#10;            }&#10;&#10;            // Save file to user-selected directory or fallback to app directory&#10;            val savedFilePath = saveFileToSelectedDirectory(fileName, decryptedBytes, saveDirectoryUri)&#10;&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File decrypted and saved successfully: $fileName&quot;)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to: $savedFilePath&quot;)&#10;&#10;            // Broadcast success with file path and consistent action&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, true)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;File received and decrypted successfully: $fileName&quot;)&#10;            broadcastIntent.putExtra(&quot;file_path&quot;, savedFilePath)&#10;            sendBroadcast(broadcastIntent)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error receiving file: ${e.message}&quot;)&#10;            val broadcastIntent = Intent(&quot;com.skl.securefastfiletransfer.FILE_TRANSFER_COMPLETE&quot;)&#10;            broadcastIntent.putExtra(&quot;success&quot;, false)&#10;            broadcastIntent.putExtra(&quot;message&quot;, &quot;Failed to receive file: ${e.message}&quot;)&#10;            sendBroadcast(broadcastIntent)&#10;        }&#10;    }&#10;&#10;    private fun saveFileToSelectedDirectory(fileName: String, fileBytes: ByteArray, saveDirectoryUri: Uri?): String {&#10;        Log.d(&quot;FileTransferService&quot;, &quot;Attempting to save file: $fileName&quot;)&#10;        Log.d(&quot;FileTransferService&quot;, &quot;Save directory URI: $saveDirectoryUri&quot;)&#10;&#10;        return try {&#10;            if (saveDirectoryUri != null) {&#10;                Log.d(&quot;FileTransferService&quot;, &quot;Using user-selected directory&quot;)&#10;                // Save to user-selected directory using DocumentFile&#10;                val directory = DocumentFile.fromTreeUri(this, saveDirectoryUri)&#10;                if (directory != null &amp;&amp; directory.exists()) {&#10;                    Log.d(&quot;FileTransferService&quot;, &quot;Directory is valid and exists&quot;)&#10;                    val newFile = directory.createFile(&quot;*/*&quot;, fileName)&#10;                    if (newFile != null) {&#10;                        Log.d(&quot;FileTransferService&quot;, &quot;Created new file in selected directory&quot;)&#10;                        contentResolver.openOutputStream(newFile.uri)?.use { outputStream -&gt;&#10;                            outputStream.write(fileBytes)&#10;                        }&#10;                        Log.d(&quot;FileTransferService&quot;, &quot;File saved successfully to: ${newFile.uri}&quot;)&#10;                        return newFile.uri.toString()&#10;                    } else {&#10;                        Log.w(&quot;FileTransferService&quot;, &quot;Failed to create file in selected directory&quot;)&#10;                    }&#10;                } else {&#10;                    Log.w(&quot;FileTransferService&quot;, &quot;Selected directory is null or doesn't exist&quot;)&#10;                }&#10;            } else {&#10;                Log.d(&quot;FileTransferService&quot;, &quot;No save directory provided, using fallback&quot;)&#10;            }&#10;&#10;            // Fallback: Save to app's external files directory&#10;            Log.d(&quot;FileTransferService&quot;, &quot;Using fallback directory&quot;)&#10;            val downloadsDir = File(getExternalFilesDir(null), &quot;Downloads&quot;)&#10;            if (!downloadsDir.exists()) {&#10;                downloadsDir.mkdirs()&#10;            }&#10;            val receivedFile = File(downloadsDir, fileName)&#10;            receivedFile.writeBytes(fileBytes)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to fallback location: ${receivedFile.absolutePath}&quot;)&#10;            receivedFile.absolutePath&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FileTransferService&quot;, &quot;Error saving file: ${e.message}&quot;)&#10;            // Emergency fallback: Save to cache directory&#10;            val cacheFile = File(cacheDir, fileName)&#10;            cacheFile.writeBytes(fileBytes)&#10;            Log.d(&quot;FileTransferService&quot;, &quot;File saved to emergency cache: ${cacheFile.absolutePath}&quot;)&#10;            cacheFile.absolutePath&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/WiFiTransferHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/skl/securefastfiletransfer/WiFiTransferHelper.kt" />
              <option name="originalContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;import java.io.*&#10;import java.net.*&#10;import java.util.concurrent.Executors&#10;&#10;class WiFiTransferHelper(private val context: Context) {&#10;&#10;    interface TransferListener {&#10;        fun onTransferProgress(bytesTransferred: Long, totalBytes: Long)&#10;        fun onTransferComplete(success: Boolean, message: String)&#10;        fun onPeerDiscovered(peerIp: String)&#10;        fun onConnectionEstablished(peerIp: String)&#10;    }&#10;&#10;    private var transferListener: TransferListener? = null&#10;    private var discoverySocket: DatagramSocket? = null&#10;    private var secretServerSocket: ServerSocket? = null&#10;    private var fileServerSocket: ServerSocket? = null&#10;    private var currentSecret: String? = null&#10;    private val executor = Executors.newCachedThreadPool()&#10;    private var isRunning = false&#10;    private var isSender = false&#10;&#10;    companion object {&#10;        private const val DISCOVERY_PORT = 8987&#10;        private const val SECRET_VERIFICATION_PORT = 8988&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;        private const val BROADCAST_MESSAGE = &quot;NFConnect_Discovery&quot;&#10;    }&#10;&#10;    fun setTransferListener(listener: TransferListener) {&#10;        this.transferListener = listener&#10;    }&#10;&#10;    fun startSender(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = true&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting sender with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Start discovery server to respond to receiver's broadcast&#10;        executor.submit {&#10;            startDiscoveryServer()&#10;        }&#10;&#10;        // Start secret verification server&#10;        executor.submit {&#10;            startSecretVerificationServer()&#10;        }&#10;    }&#10;&#10;    fun startReceiver(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = false&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting receiver with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Small delay to ensure sender is ready&#10;        Thread.sleep(2000)&#10;&#10;        // Start discovery by broadcasting&#10;        executor.submit {&#10;            discoverSender()&#10;        }&#10;    }&#10;&#10;    private fun startDiscoveryServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            discoverySocket?.close()&#10;&#10;            discoverySocket = DatagramSocket(DISCOVERY_PORT)&#10;            discoverySocket?.soTimeout = 30000 // 30 second timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server listening on port $DISCOVERY_PORT&quot;)&#10;            val buffer = ByteArray(1024)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val packet = DatagramPacket(buffer, buffer.size)&#10;                    discoverySocket?.receive(packet)&#10;&#10;                    val message = String(packet.data, 0, packet.length)&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received discovery message: $message&quot;)&#10;&#10;                    if (message.startsWith(BROADCAST_MESSAGE)) {&#10;                        // Respond to discovery request&#10;                        val response = &quot;NFConnect_Response:${currentSecret?.take(8)}&quot;&#10;                        val responsePacket = DatagramPacket(&#10;                            response.toByteArray(),&#10;                            response.length,&#10;                            packet.address,&#10;                            packet.port&#10;                        )&#10;                        discoverySocket?.send(responsePacket)&#10;&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Responded to discovery from ${packet.address.hostAddress}&quot;)&#10;                        transferListener?.onPeerDiscovered(packet.address.hostAddress)&#10;&#10;                        // Break after first successful response to avoid conflicts&#10;                        break&#10;                    }&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start discovery server: ${e.message}&quot;)&#10;        } finally {&#10;            discoverySocket?.close()&#10;        }&#10;    }&#10;&#10;    private fun discoverSender() {&#10;        try {&#10;            val socket = DatagramSocket()&#10;            socket.broadcast = true&#10;            socket.soTimeout = 5000 // 5 second timeout per attempt&#10;&#10;            val message = &quot;$BROADCAST_MESSAGE:${currentSecret?.take(8)}&quot;&#10;            val buffer = message.toByteArray()&#10;&#10;            // Try to discover on multiple network addresses&#10;            val addresses = listOf(&#10;                &quot;255.255.255.255&quot;,&#10;                &quot;192.168.1.255&quot;,&#10;                &quot;192.168.0.255&quot;,&#10;                &quot;10.0.0.255&quot;&#10;            )&#10;&#10;            var found = false&#10;&#10;            for (attempt in 1..5) {&#10;                if (found) break&#10;&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery attempt $attempt&quot;)&#10;&#10;                for (addressString in addresses) {&#10;                    try {&#10;                        val broadcast = InetAddress.getByName(addressString)&#10;                        val packet = DatagramPacket(buffer, buffer.size, broadcast, DISCOVERY_PORT)&#10;                        socket.send(packet)&#10;&#10;                        // Listen for response&#10;                        val responseBuffer = ByteArray(1024)&#10;                        val responsePacket = DatagramPacket(responseBuffer, responseBuffer.size)&#10;                        socket.receive(responsePacket)&#10;&#10;                        val response = String(responsePacket.data, 0, responsePacket.length)&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received response: $response&quot;)&#10;&#10;                        if (response.startsWith(&quot;NFConnect_Response&quot;)) {&#10;                            val senderIp = responsePacket.address.hostAddress&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Found sender at: $senderIp&quot;)&#10;                            transferListener?.onPeerDiscovered(senderIp)&#10;&#10;                            // Small delay before verification&#10;                            Thread.sleep(1000)&#10;&#10;                            // Attempt secret verification&#10;                            verifySecretWithSender(senderIp)&#10;                            found = true&#10;                            break&#10;                        }&#10;                    } catch (e: SocketTimeoutException) {&#10;                        // Try next address&#10;                        continue&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error with address $addressString: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                if (!found) {&#10;                    Thread.sleep(2000) // Wait before next attempt&#10;                }&#10;            }&#10;&#10;            socket.close()&#10;&#10;            if (!found) {&#10;                transferListener?.onTransferComplete(false, &quot;Could not find sender device&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Discovery failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startSecretVerificationServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            secretServerSocket?.close()&#10;&#10;            secretServerSocket = ServerSocket(SECRET_VERIFICATION_PORT)&#10;            secretServerSocket?.soTimeout = 60000 // 1 minute timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server listening on port $SECRET_VERIFICATION_PORT&quot;)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val client = secretServerSocket?.accept() ?: break&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Client connected for secret verification&quot;)&#10;&#10;                    executor.submit {&#10;                        handleSecretVerification(client)&#10;                    }&#10;&#10;                    // Only handle one verification to avoid conflicts&#10;                    break&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start secret verification server: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleSecretVerification(client: Socket) {&#10;        try {&#10;            client.soTimeout = 10000 // 10 second timeout&#10;            val input = BufferedReader(InputStreamReader(client.getInputStream()))&#10;            val output = PrintWriter(client.getOutputStream(), true)&#10;&#10;            val receivedSecret = input.readLine()&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received secret verification: ${receivedSecret?.take(8)}...&quot;)&#10;&#10;            if (receivedSecret == currentSecret) {&#10;                output.println(&quot;SECRET_VERIFIED&quot;)&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onConnectionEstablished(client.inetAddress.hostAddress)&#10;            } else {&#10;                output.println(&quot;SECRET_REJECTED&quot;)&#10;                Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected from client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Secret mismatch - security check failed&quot;)&#10;            }&#10;&#10;            client.close()&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Secret verification failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun verifySecretWithSender(senderIp: String) {&#10;        executor.submit {&#10;            try {&#10;                // Multiple connection attempts with delays&#10;                var connected = false&#10;&#10;                for (attempt in 1..3) {&#10;                    try {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt to $senderIp&quot;)&#10;&#10;                        val socket = Socket()&#10;                        socket.connect(InetSocketAddress(senderIp, SECRET_VERIFICATION_PORT), 10000)&#10;                        socket.soTimeout = 10000&#10;&#10;                        val output = PrintWriter(socket.getOutputStream(), true)&#10;                        val input = BufferedReader(InputStreamReader(socket.getInputStream()))&#10;&#10;                        output.println(currentSecret)&#10;                        val response = input.readLine()&#10;&#10;                        if (response == &quot;SECRET_VERIFIED&quot;) {&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with sender&quot;)&#10;                            transferListener?.onConnectionEstablished(senderIp)&#10;                            connected = true&#10;                            socket.close()&#10;                            break&#10;                        } else {&#10;                            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected by sender: $response&quot;)&#10;                            socket.close()&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt failed: ${e.message}&quot;)&#10;                        if (attempt &lt; 3) {&#10;                            Thread.sleep(2000) // Wait before retry&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (!connected) {&#10;                    transferListener?.onTransferComplete(false, &quot;Secret verification failed after multiple attempts&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Connection failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendFile(filePath: String, peerIp: String) {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for encryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file transfer to $peerIp&quot;)&#10;&#10;        // Use updated FileTransferService&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_SEND_FILE,&#10;            filePath = filePath,&#10;            hostAddress = peerIp,&#10;            secret = currentSecret!!&#10;        )&#10;    }&#10;&#10;    fun startFileReceiver() {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for decryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file receiver&quot;)&#10;&#10;        // Use updated FileTransferService&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_RECEIVE_FILE,&#10;            secret = currentSecret!!&#10;        )&#10;    }&#10;&#10;    fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            discoverySocket?.close()&#10;            secretServerSocket?.close()&#10;            fileServerSocket?.close()&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error during cleanup: ${e.message}&quot;)&#10;        }&#10;        executor.shutdown()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.skl.securefastfiletransfer&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.util.Log&#10;import java.io.*&#10;import java.net.*&#10;import java.util.concurrent.Executors&#10;&#10;class WiFiTransferHelper(private val context: Context) {&#10;&#10;    interface TransferListener {&#10;        fun onTransferProgress(bytesTransferred: Long, totalBytes: Long)&#10;        fun onTransferComplete(success: Boolean, message: String)&#10;        fun onPeerDiscovered(peerIp: String)&#10;        fun onConnectionEstablished(peerIp: String)&#10;    }&#10;&#10;    private var transferListener: TransferListener? = null&#10;    private var discoverySocket: DatagramSocket? = null&#10;    private var secretServerSocket: ServerSocket? = null&#10;    private var fileServerSocket: ServerSocket? = null&#10;    private var currentSecret: String? = null&#10;    private val executor = Executors.newCachedThreadPool()&#10;    private var isRunning = false&#10;    private var isSender = false&#10;&#10;    companion object {&#10;        private const val DISCOVERY_PORT = 8987&#10;        private const val SECRET_VERIFICATION_PORT = 8988&#10;        private const val FILE_TRANSFER_PORT = 8989&#10;        private const val BROADCAST_MESSAGE = &quot;NFConnect_Discovery&quot;&#10;    }&#10;&#10;    fun setTransferListener(listener: TransferListener) {&#10;        this.transferListener = listener&#10;    }&#10;&#10;    fun startSender(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = true&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting sender with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Start discovery server to respond to receiver's broadcast&#10;        executor.submit {&#10;            startDiscoveryServer()&#10;        }&#10;&#10;        // Start secret verification server&#10;        executor.submit {&#10;            startSecretVerificationServer()&#10;        }&#10;    }&#10;&#10;    fun startReceiver(secret: String) {&#10;        currentSecret = secret&#10;        isRunning = true&#10;        isSender = false&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting receiver with secret: ${secret.take(8)}...&quot;)&#10;&#10;        // Small delay to ensure sender is ready&#10;        Thread.sleep(2000)&#10;&#10;        // Start discovery by broadcasting&#10;        executor.submit {&#10;            discoverSender()&#10;        }&#10;    }&#10;&#10;    private fun startDiscoveryServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            discoverySocket?.close()&#10;&#10;            discoverySocket = DatagramSocket(DISCOVERY_PORT)&#10;            discoverySocket?.soTimeout = 30000 // 30 second timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server listening on port $DISCOVERY_PORT&quot;)&#10;            val buffer = ByteArray(1024)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val packet = DatagramPacket(buffer, buffer.size)&#10;                    discoverySocket?.receive(packet)&#10;&#10;                    val message = String(packet.data, 0, packet.length)&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received discovery message: $message&quot;)&#10;&#10;                    if (message.startsWith(BROADCAST_MESSAGE)) {&#10;                        // Respond to discovery request&#10;                        val response = &quot;NFConnect_Response:${currentSecret?.take(8)}&quot;&#10;                        val responsePacket = DatagramPacket(&#10;                            response.toByteArray(),&#10;                            response.length,&#10;                            packet.address,&#10;                            packet.port&#10;                        )&#10;                        discoverySocket?.send(responsePacket)&#10;&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Responded to discovery from ${packet.address.hostAddress}&quot;)&#10;                        transferListener?.onPeerDiscovered(packet.address.hostAddress)&#10;&#10;                        // Break after first successful response to avoid conflicts&#10;                        break&#10;                    }&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start discovery server: ${e.message}&quot;)&#10;        } finally {&#10;            discoverySocket?.close()&#10;        }&#10;    }&#10;&#10;    private fun discoverSender() {&#10;        try {&#10;            val socket = DatagramSocket()&#10;            socket.broadcast = true&#10;            socket.soTimeout = 5000 // 5 second timeout per attempt&#10;&#10;            val message = &quot;$BROADCAST_MESSAGE:${currentSecret?.take(8)}&quot;&#10;            val buffer = message.toByteArray()&#10;&#10;            // Try to discover on multiple network addresses&#10;            val addresses = listOf(&#10;                &quot;255.255.255.255&quot;,&#10;                &quot;192.168.1.255&quot;,&#10;                &quot;192.168.0.255&quot;,&#10;                &quot;10.0.0.255&quot;&#10;            )&#10;&#10;            var found = false&#10;&#10;            for (attempt in 1..5) {&#10;                if (found) break&#10;&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Discovery attempt $attempt&quot;)&#10;&#10;                for (addressString in addresses) {&#10;                    try {&#10;                        val broadcast = InetAddress.getByName(addressString)&#10;                        val packet = DatagramPacket(buffer, buffer.size, broadcast, DISCOVERY_PORT)&#10;                        socket.send(packet)&#10;&#10;                        // Listen for response&#10;                        val responseBuffer = ByteArray(1024)&#10;                        val responsePacket = DatagramPacket(responseBuffer, responseBuffer.size)&#10;                        socket.receive(responsePacket)&#10;&#10;                        val response = String(responsePacket.data, 0, responsePacket.length)&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received response: $response&quot;)&#10;&#10;                        if (response.startsWith(&quot;NFConnect_Response&quot;)) {&#10;                            val senderIp = responsePacket.address.hostAddress&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Found sender at: $senderIp&quot;)&#10;                            transferListener?.onPeerDiscovered(senderIp)&#10;&#10;                            // Small delay before verification&#10;                            Thread.sleep(1000)&#10;&#10;                            // Attempt secret verification&#10;                            verifySecretWithSender(senderIp)&#10;                            found = true&#10;                            break&#10;                        }&#10;                    } catch (e: SocketTimeoutException) {&#10;                        // Try next address&#10;                        continue&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error with address $addressString: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                if (!found) {&#10;                    Thread.sleep(2000) // Wait before next attempt&#10;                }&#10;            }&#10;&#10;            socket.close()&#10;&#10;            if (!found) {&#10;                transferListener?.onTransferComplete(false, &quot;Could not find sender device&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Discovery error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Discovery failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startSecretVerificationServer() {&#10;        try {&#10;            // Close existing socket if any&#10;            secretServerSocket?.close()&#10;&#10;            secretServerSocket = ServerSocket(SECRET_VERIFICATION_PORT)&#10;            secretServerSocket?.soTimeout = 60000 // 1 minute timeout&#10;&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server listening on port $SECRET_VERIFICATION_PORT&quot;)&#10;&#10;            while (isRunning) {&#10;                try {&#10;                    val client = secretServerSocket?.accept() ?: break&#10;                    Log.d(&quot;WiFiTransferHelper&quot;, &quot;Client connected for secret verification&quot;)&#10;&#10;                    executor.submit {&#10;                        handleSecretVerification(client)&#10;                    }&#10;&#10;                    // Only handle one verification to avoid conflicts&#10;                    break&#10;                } catch (e: SocketTimeoutException) {&#10;                    if (isRunning) {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret server timeout, continuing...&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    if (isRunning) {&#10;                        Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification server error: ${e.message}&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Failed to start secret verification server: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleSecretVerification(client: Socket) {&#10;        try {&#10;            client.soTimeout = 10000 // 10 second timeout&#10;            val input = BufferedReader(InputStreamReader(client.getInputStream()))&#10;            val output = PrintWriter(client.getOutputStream(), true)&#10;&#10;            val receivedSecret = input.readLine()&#10;            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Received secret verification: ${receivedSecret?.take(8)}...&quot;)&#10;&#10;            if (receivedSecret == currentSecret) {&#10;                output.println(&quot;SECRET_VERIFIED&quot;)&#10;                Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onConnectionEstablished(client.inetAddress.hostAddress)&#10;            } else {&#10;                output.println(&quot;SECRET_REJECTED&quot;)&#10;                Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected from client: ${client.inetAddress.hostAddress}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Secret mismatch - security check failed&quot;)&#10;            }&#10;&#10;            client.close()&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;            transferListener?.onTransferComplete(false, &quot;Secret verification failed: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun verifySecretWithSender(senderIp: String) {&#10;        executor.submit {&#10;            try {&#10;                // Multiple connection attempts with delays&#10;                var connected = false&#10;&#10;                for (attempt in 1..3) {&#10;                    try {&#10;                        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt to $senderIp&quot;)&#10;&#10;                        val socket = Socket()&#10;                        socket.connect(InetSocketAddress(senderIp, SECRET_VERIFICATION_PORT), 10000)&#10;                        socket.soTimeout = 10000&#10;&#10;                        val output = PrintWriter(socket.getOutputStream(), true)&#10;                        val input = BufferedReader(InputStreamReader(socket.getInputStream()))&#10;&#10;                        output.println(currentSecret)&#10;                        val response = input.readLine()&#10;&#10;                        if (response == &quot;SECRET_VERIFIED&quot;) {&#10;                            Log.d(&quot;WiFiTransferHelper&quot;, &quot;Secret verified with sender&quot;)&#10;                            transferListener?.onConnectionEstablished(senderIp)&#10;                            connected = true&#10;                            socket.close()&#10;                            break&#10;                        } else {&#10;                            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret rejected by sender: $response&quot;)&#10;                            socket.close()&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(&quot;WiFiTransferHelper&quot;, &quot;Secret verification attempt $attempt failed: ${e.message}&quot;)&#10;                        if (attempt &lt; 3) {&#10;                            Thread.sleep(2000) // Wait before retry&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (!connected) {&#10;                    transferListener?.onTransferComplete(false, &quot;Secret verification failed after multiple attempts&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;WiFiTransferHelper&quot;, &quot;Secret verification error: ${e.message}&quot;)&#10;                transferListener?.onTransferComplete(false, &quot;Connection failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendFile(filePath: String, peerIp: String) {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for encryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file transfer to $peerIp&quot;)&#10;&#10;        // Use updated FileTransferService&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_SEND_FILE,&#10;            filePath = filePath,&#10;            hostAddress = peerIp,&#10;            secret = currentSecret!!&#10;        )&#10;    }&#10;&#10;    fun startFileReceiver(saveDirectory: Uri? = null) {&#10;        if (currentSecret == null) {&#10;            transferListener?.onTransferComplete(false, &quot;No secret available for decryption&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;WiFiTransferHelper&quot;, &quot;Starting encrypted file receiver&quot;)&#10;&#10;        // Use updated FileTransferService with save directory&#10;        FileTransferService.startService(&#10;            context = context,&#10;            action = FileTransferService.ACTION_RECEIVE_FILE,&#10;            secret = currentSecret!!,&#10;            saveDirectoryUri = saveDirectory&#10;        )&#10;    }&#10;&#10;    fun cleanup() {&#10;        isRunning = false&#10;        try {&#10;            discoverySocket?.close()&#10;            secretServerSocket?.close()&#10;            fileServerSocket?.close()&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;WiFiTransferHelper&quot;, &quot;Error during cleanup: ${e.message}&quot;)&#10;        }&#10;        executor.shutdown()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/file_paths.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/file_paths.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;external-files-path name=&quot;my_images&quot; path=&quot;Documents/&quot; /&gt;&#10;    &lt;external-files-path name=&quot;my_downloads&quot; path=&quot;Downloads/&quot; /&gt;&#10;    &lt;external-path name=&quot;external_storage&quot; path=&quot;.&quot; /&gt;&#10;&lt;/paths&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>